{"meta":{"title":"迷途","subtitle":"","description":"https://wenchengz.cn","author":"迷途","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-07-27T09:30:39.000Z","updated":"2022-07-29T04:37:35.583Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-27T09:30:39.000Z","updated":"2022-07-27T09:30:39.304Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-07-29T06:07:37.078Z","updated":"2022-07-29T05:51:14.895Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":"categories - 迷途 /* 首屏样式 */ #safearea { display: none; } /* * Workaround for Chrome bug, part 1 * Chunk rendering for all but the first article. * /layout/_partial/scripts/content-visibility-scroll-fix.ejs */ .post-story + .post-story { content-visibility: auto; contain-intrinsic-size: 10px 500px; } :root { --color-site-body: #f4f4f4; --color-site-bg: #f4f4f4; --color-site-inner: #fff; --color-site-footer: #666; --color-card: #fff; --color-text: #444; --color-block: #f6f6f6; --color-inlinecode: #c74f00; --color-codeblock: #fff7ea; --color-h1: #3a3a3a; --color-h2: #3a3a3a; --color-h3: #333; --color-h4: #444; --color-h5: #555; --color-h6: #666; --color-p: #444; --color-list: #666; --color-list-hl: #30ad91; --color-meta: #888; --color-read-bkg: #e0d8c8; --color-read-post: #f8f1e2; --color-copyright-bkg: #f5f5f5; } * { box-sizing: border-box; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; outline: none; margin: 0; padding: 0; } *::-webkit-scrollbar { height: 4px; width: 4px; } *::-webkit-scrollbar-track-piece { background: transparent; } *::-webkit-scrollbar-thumb { background: #3dd9b6; cursor: pointer; border-radius: 2px; -webkit-border-radius: 2px; } *::-webkit-scrollbar-thumb:hover { background: #ff5722; } html { color: var(--color-text); width: 100%; height: 100%; font-family: UbuntuMono, \"Varela Round\", \"PingFang SC\", \"Microsoft YaHei\", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif; font-size: 16px; } html >::-webkit-scrollbar { height: 4px; width: 4px; } html >::-webkit-scrollbar-track-piece { background: transparent; } html >::-webkit-scrollbar-thumb { background: #3dd9b6; cursor: pointer; border-radius: 2px; -webkit-border-radius: 2px; } html >::-webkit-scrollbar-thumb:hover { background: #ff5722; } body { background-color: var(--color-site-body); text-rendering: optimizelegibility; -webkit-tap-highlight-color: rgba(0,0,0,0); line-height: 1.6; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; } body.modal-active { overflow: hidden; } @media screen and (max-width: 680px) { body.modal-active { position: fixed; top: 0; right: 0; bottom: 0; left: 0; } } a { color: #2092ec; cursor: pointer; text-decoration: none; transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; } a:hover { color: #ff5722; } a:active, a:hover { outline: 0; } ul, ol { padding-left: 0; } ul li, ol li { list-style: none; } header { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: block; } img { border: 0; background: none; max-width: 100%; } svg:not(:root) { overflow: hidden; } hr { -moz-box-sizing: content-box; box-sizing: content-box; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; height: 0; border: 0; border-radius: 1px; -webkit-border-radius: 1px; border-bottom: 1px solid rgba(68,68,68,0.1); } button, input { color: inherit; font: inherit; margin: 0; } button { overflow: visible; text-transform: none; -webkit-appearance: button; cursor: pointer; } @supports (backdrop-filter: blur(20px)) { .blur { background: rgba(255,255,255,0.9) !important; backdrop-filter: saturate(200%) blur(20px); } } .shadow { box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); } .shadow.floatable { transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; } .shadow.floatable:hover { box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1); -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1); } #l_cover { min-height: 64px; } .cover-wrapper { top: 0; left: 0; max-width: 100%; height: 100vh; display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; flex-wrap: nowrap; -webkit-flex-wrap: nowrap; -khtml-flex-wrap: nowrap; -moz-flex-wrap: nowrap; -o-flex-wrap: nowrap; -ms-flex-wrap: nowrap; -webkit-box-direction: normal; -moz-box-direction: normal; -webkit-box-orient: vertical; -moz-box-orient: vertical; -webkit-flex-direction: column; -ms-flex-direction: column; flex-direction: column; align-items: center; align-self: center; align-content: center; color: var(--color-site-inner); padding: 0 16px; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; position: relative; overflow: hidden; margin-bottom: -100px; } .cover-wrapper .cover-bg { position: absolute; width: 100%; height: 100%; background-position: center; background-size: cover; -webkit-background-size: cover; -moz-background-size: cover; } .cover-wrapper .cover-bg.lazyload:not(.loaded) { opacity: 0; -webkit-opacity: 0; -moz-opacity: 0; } .cover-wrapper .cover-bg.lazyload.loaded { animation-delay: 0s; animation-duration: 0.5s; animation-fill-mode: forwards; animation-timing-function: ease-out; animation-name: fadeIn; } @-moz-keyframes fadeIn { 0% { opacity: 0; -webkit-opacity: 0; -moz-opacity: 0; filter: blur(12px); transform: scale(1.02); -webkit-transform: scale(1.02); -khtml-transform: scale(1.02); -moz-transform: scale(1.02); -o-transform: scale(1.02); -ms-transform: scale(1.02); } 100% { opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } } @-webkit-keyframes fadeIn { 0% { opacity: 0; -webkit-opacity: 0; -moz-opacity: 0; filter: blur(12px); transform: scale(1.02); -webkit-transform: scale(1.02); -khtml-transform: scale(1.02); -moz-transform: scale(1.02); -o-transform: scale(1.02); -ms-transform: scale(1.02); } 100% { opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } } @-o-keyframes fadeIn { 0% { opacity: 0; -webkit-opacity: 0; -moz-opacity: 0; filter: blur(12px); transform: scale(1.02); -webkit-transform: scale(1.02); -khtml-transform: scale(1.02); -moz-transform: scale(1.02); -o-transform: scale(1.02); -ms-transform: scale(1.02); } 100% { opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } } @keyframes fadeIn { 0% { opacity: 0; -webkit-opacity: 0; -moz-opacity: 0; filter: blur(12px); transform: scale(1.02); -webkit-transform: scale(1.02); -khtml-transform: scale(1.02); -moz-transform: scale(1.02); -o-transform: scale(1.02); -ms-transform: scale(1.02); } 100% { opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } } .cover-wrapper .cover-body { z-index: 1; position: relative; width: 100%; height: 100%; } .cover-wrapper#full { height: calc(100vh + 100px); padding-bottom: 100px; } .cover-wrapper#half { max-height: 640px; min-height: 400px; height: calc(36vh - 64px + 200px); } .cover-wrapper #scroll-down { width: 100%; height: 64px; position: absolute; bottom: 100px; text-align: center; cursor: pointer; } .cover-wrapper #scroll-down .scroll-down-effects { color: #fff; font-size: 24px; line-height: 64px; position: absolute; width: 24px; left: calc(50% - 12px); text-shadow: 0 1px 2px rgba(0,0,0,0.1); animation: scroll-down-effect 1.5s infinite; -webkit-animation: scroll-down-effect 1.5s infinite; -khtml-animation: scroll-down-effect 1.5s infinite; -moz-animation: scroll-down-effect 1.5s infinite; -o-animation: scroll-down-effect 1.5s infinite; -ms-animation: scroll-down-effect 1.5s infinite; } @-moz-keyframes scroll-down-effect { 0% { top: 0; opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } 50% { top: -16px; opacity: 0.4; -webkit-opacity: 0.4; -moz-opacity: 0.4; } 100% { top: 0; opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } } @-webkit-keyframes scroll-down-effect { 0% { top: 0; opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } 50% { top: -16px; opacity: 0.4; -webkit-opacity: 0.4; -moz-opacity: 0.4; } 100% { top: 0; opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } } @-o-keyframes scroll-down-effect { 0% { top: 0; opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } 50% { top: -16px; opacity: 0.4; -webkit-opacity: 0.4; -moz-opacity: 0.4; } 100% { top: 0; opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } } @keyframes scroll-down-effect { 0% { top: 0; opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } 50% { top: -16px; opacity: 0.4; -webkit-opacity: 0.4; -moz-opacity: 0.4; } 100% { top: 0; opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } } .cover-wrapper .cover-body { margin-top: 64px; margin-bottom: 100px; } .cover-wrapper .cover-body, .cover-wrapper .cover-body .top, .cover-wrapper .cover-body .bottom { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; -webkit-box-direction: normal; -moz-box-direction: normal; -webkit-box-orient: vertical; -moz-box-orient: vertical; -webkit-flex-direction: column; -ms-flex-direction: column; flex-direction: column; align-items: center; justify-content: center; -webkit-justify-content: center; -khtml-justify-content: center; -moz-justify-content: center; -o-justify-content: center; -ms-justify-content: center; max-width: 100%; } .cover-wrapper .cover-body .bottom { margin-top: 32px; } .cover-wrapper .cover-body .title { font-family: \"Varela Round\", \"PingFang SC\", \"Microsoft YaHei\", Helvetica, Arial, Helvetica, monospace; font-size: 3.125rem; line-height: 1.2; text-shadow: 0 1px 2px rgba(0,0,0,0.1); } .cover-wrapper .cover-body .subtitle { font-size: 20px; } .cover-wrapper .cover-body .logo { max-height: 120px; max-width: calc(100% - 4 * 16px); } @media screen and (min-height: 1024px) { .cover-wrapper .cover-body .title { font-size: 3rem; } .cover-wrapper .cover-body .subtitle { font-size: 1.05rem; } .cover-wrapper .cover-body .logo { max-height: 150px; } } .cover-wrapper .cover-body .m_search { position: relative; max-width: calc(100% - 16px); width: 320px; vertical-align: middle; } .cover-wrapper .cover-body .m_search .form { position: relative; display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: block; width: 100%; } .cover-wrapper .cover-body .m_search .icon, .cover-wrapper .cover-body .m_search .input { transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; } .cover-wrapper .cover-body .m_search .icon { position: absolute; display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: block; line-height: 2.5rem; width: 32px; top: 0; left: 5px; color: rgba(68,68,68,0.75); } .cover-wrapper .cover-body .m_search .input { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: block; height: 2.5rem; width: 100%; box-shadow: none; -webkit-box-shadow: none; box-sizing: border-box; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; font-size: 0.875rem; -webkit-appearance: none; padding-left: 36px; border-radius: 1.4rem; -webkit-border-radius: 1.4rem; background: rgba(255,255,255,0.6); backdrop-filter: blur(10px); border: none; color: var(--color-text); } @media screen and (max-width: 500px) { .cover-wrapper .cover-body .m_search .input { padding-left: 36px; } } .cover-wrapper .cover-body .m_search .input:hover { background: rgba(255,255,255,0.8); } .cover-wrapper .cover-body .m_search .input:focus { background: #fff; } .cover-wrapper .list-h { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; -webkit-box-direction: normal; -moz-box-direction: normal; -webkit-box-orient: horizontal; -moz-box-orient: horizontal; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; flex-wrap: wrap; -webkit-flex-wrap: wrap; -khtml-flex-wrap: wrap; -moz-flex-wrap: wrap; -o-flex-wrap: wrap; -ms-flex-wrap: wrap; align-items: stretch; border-radius: 4px; -webkit-border-radius: 4px; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; } .cover-wrapper .list-h a { -webkit-box-flex: 1; -moz-box-flex: 1; -webkit-flex: 1 0; -ms-flex: 1 0; flex: 1 0; display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; font-weight: 600; } .cover-wrapper .list-h a img { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: block; border-radius: 2px; -webkit-border-radius: 2px; margin: 4px; min-width: 40px; max-width: 44px; } @media screen and (max-width: 768px) { .cover-wrapper .list-h a img { min-width: 36px; max-width: 40px; } } @media screen and (max-width: 500px) { .cover-wrapper .list-h a img { margin: 2px 4px; min-width: 32px; max-width: 36px; } } @media screen and (max-width: 375px) { .cover-wrapper .list-h a img { min-width: 28px; max-width: 32px; } } .cover-wrapper { max-width: 100%; } .cover-wrapper.search .bottom .menu { margin-top: 16px; } .cover-wrapper.search .bottom .menu .list-h a { white-space: nowrap; -webkit-box-direction: normal; -moz-box-direction: normal; -webkit-box-orient: horizontal; -moz-box-orient: horizontal; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; align-items: baseline; padding: 2px; margin: 4px; color: var(--color-site-inner); opacity: 0.75; -webkit-opacity: 0.75; -moz-opacity: 0.75; text-shadow: 0 1px 2px rgba(0,0,0,0.05); border-bottom: 2px solid transparent; } .cover-wrapper.search .bottom .menu .list-h a i { margin-right: 4px; } .cover-wrapper.search .bottom .menu .list-h a p { font-size: 0.9375rem; } .cover-wrapper.search .bottom .menu .list-h a:hover, .cover-wrapper.search .bottom .menu .list-h a.active, .cover-wrapper.search .bottom .menu .list-h a:active { opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; border-bottom: 2px solid var(--color-site-inner); } .cover-wrapper.dock .menu, .cover-wrapper.featured .menu, .cover-wrapper.focus .menu { border-radius: 6px; -webkit-border-radius: 6px; } .cover-wrapper.dock .menu .list-h a, .cover-wrapper.featured .menu .list-h a, .cover-wrapper.focus .menu .list-h a { -webkit-box-direction: normal; -moz-box-direction: normal; -webkit-box-orient: vertical; -moz-box-orient: vertical; -webkit-flex-direction: column; -ms-flex-direction: column; flex-direction: column; align-items: center; padding: 12px; line-height: 24px; border-radius: 4px; -webkit-border-radius: 4px; border-bottom: none; text-align: center; align-content: flex-end; color: rgba(68,68,68,0.7); font-size: 1.5rem; } @media screen and (max-width: 500px) { .cover-wrapper.dock .menu .list-h a, .cover-wrapper.featured .menu .list-h a, .cover-wrapper.focus .menu .list-h a { padding: 12px 8px; } } .cover-wrapper.dock .menu .list-h a i, .cover-wrapper.featured .menu .list-h a i, .cover-wrapper.focus .menu .list-h a i { margin: 8px; } .cover-wrapper.dock .menu .list-h a p, .cover-wrapper.featured .menu .list-h a p, .cover-wrapper.focus .menu .list-h a p { font-size: 0.875rem; } .cover-wrapper.dock .menu .list-h a.active, .cover-wrapper.featured .menu .list-h a.active, .cover-wrapper.focus .menu .list-h a.active { background: var(--color-card); backdrop-filter: none; } .cover-wrapper.dock .menu .list-h a.active i, .cover-wrapper.featured .menu .list-h a.active i, .cover-wrapper.focus .menu .list-h a.active i, .cover-wrapper.dock .menu .list-h a.active i+p, .cover-wrapper.featured .menu .list-h a.active i+p, .cover-wrapper.focus .menu .list-h a.active i+p { color: #3dd9b6; } .cover-wrapper.dock .menu .list-h a.active img+p, .cover-wrapper.featured .menu .list-h a.active img+p, .cover-wrapper.focus .menu .list-h a.active img+p { color: var(--color-text); } .cover-wrapper.dock .menu .list-h a:hover, .cover-wrapper.featured .menu .list-h a:hover, .cover-wrapper.focus .menu .list-h a:hover { background: var(--color-card); } .cover-wrapper.dock .top { margin-bottom: 48px; } .cover-wrapper.dock .menu { background: rgba(255,255,255,0.5); position: absolute; bottom: 0; max-width: 100%; } .cover-wrapper.dock .menu .list-h { flex-wrap: nowrap; -webkit-flex-wrap: nowrap; -khtml-flex-wrap: nowrap; -moz-flex-wrap: nowrap; -o-flex-wrap: nowrap; -ms-flex-wrap: nowrap; margin: 4px; } .cover-wrapper.dock .menu .list-h a+a { margin-left: 4px; } @media screen and (max-width: 500px) { .cover-wrapper.dock .menu .list-h { overflow-x: scroll; } .cover-wrapper.dock .menu .list-h::-webkit-scrollbar { height: 0; width: 0; } .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-track-piece { background: transparent; } .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb { background: #3dd9b6; cursor: pointer; border-radius: 0; -webkit-border-radius: 0; } .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb:hover { background: #ff5722; } } @supports (backdrop-filter: blur(20px)) { .cover-wrapper.dock .menu { background: rgba(255,255,255,0.5); backdrop-filter: saturate(200%) blur(20px); } } @font-face { font-family: 'UbuntuMono'; src: url(\"https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf\"); font-weight: 'normal'; font-style: 'normal'; font-display: swap; } @font-face { font-family: 'Varela Round'; src: url(\"https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf\"); font-weight: 'normal'; font-style: 'normal'; font-display: swap; } .l_header { position: fixed; z-index: 1000; top: 0; width: 100%; height: 64px; background: var(--color-card); box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); } .l_header.auto { transition: opacity 0.4s ease; -webkit-transition: opacity 0.4s ease; -khtml-transition: opacity 0.4s ease; -moz-transition: opacity 0.4s ease; -o-transition: opacity 0.4s ease; -ms-transition: opacity 0.4s ease; visibility: hidden; } .l_header.auto.show { opacity: 1 !important; -webkit-opacity: 1 !important; -moz-opacity: 1 !important; visibility: visible; } .l_header .container { margin-left: 16px; margin-right: 16px; } .l_header #wrapper { height: 100%; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; } .l_header #wrapper .nav-main, .l_header #wrapper .nav-sub { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; flex-wrap: nowrap; -webkit-flex-wrap: nowrap; -khtml-flex-wrap: nowrap; -moz-flex-wrap: nowrap; -o-flex-wrap: nowrap; -ms-flex-wrap: nowrap; justify-content: space-between; -webkit-justify-content: space-between; -khtml-justify-content: space-between; -moz-justify-content: space-between; -o-justify-content: space-between; -ms-justify-content: space-between; align-items: center; } .l_header #wrapper .nav-main { transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; } .l_header #wrapper.sub .nav-main { transform: translateY(-64px); -webkit-transform: translateY(-64px); -khtml-transform: translateY(-64px); -moz-transform: translateY(-64px); -o-transform: translateY(-64px); -ms-transform: translateY(-64px); } .l_header #wrapper .nav-sub { transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; opacity: 0; -webkit-opacity: 0; -moz-opacity: 0; height: 64px; width: calc(100% - 2 * 16px); position: absolute; } .l_header #wrapper .nav-sub ::-webkit-scrollbar { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: none; } @media screen and (min-width: 2048px) { .l_header #wrapper .nav-sub { max-width: 55vw; margin: auto; } } .l_header #wrapper.sub .nav-sub { opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } .l_header #wrapper .title { position: relative; color: var(--color-text); padding-left: 24px; max-height: 64px; } .l_header #wrapper .nav-main .title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-shrink: 0; line-height: 64px; padding: 0 24px; font-size: 1.25rem; font-family: \"Varela Round\", \"PingFang SC\", \"Microsoft YaHei\", Helvetica, Arial, Helvetica, monospace; } .l_header #wrapper .nav-main .title img { height: 64px; } .l_header .nav-sub { max-width: 1080px; margin: auto; } .l_header .nav-sub .title { font-weight: bold; font-family: UbuntuMono, \"Varela Round\", \"PingFang SC\", \"Microsoft YaHei\", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif; line-height: 1.2; max-height: 64px; white-space: normal; flex-shrink: 1; } .l_header .switcher { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: none; line-height: 64px; align-items: center; } .l_header .switcher .s-toc { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: none; } @media screen and (max-width: 768px) { .l_header .switcher .s-toc { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; } } .l_header .switcher >li { height: 48px; transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; margin: 2px; } @media screen and (max-width: 500px) { .l_header .switcher >li { margin: 0 1px; height: 48px; } } .l_header .switcher >li >a { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; justify-content: center; -webkit-justify-content: center; -khtml-justify-content: center; -moz-justify-content: center; -o-justify-content: center; -ms-justify-content: center; align-items: center; width: 48px; height: 48px; padding: 0.85em 1.1em; border-radius: 100px; -webkit-border-radius: 100px; border: none; transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; color: #3dd9b6; } .l_header .switcher >li >a:hover { border: none; } .l_header .switcher >li >a.active, .l_header .switcher >li >a:active { border: none; background: var(--color-site-bg); } @media screen and (max-width: 500px) { .l_header .switcher >li >a { width: 36px; height: 48px; } } .l_header .nav-sub .switcher { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; } .l_header .m_search { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; height: 64px; width: 240px; transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; } @media screen and (max-width: 1024px) { .l_header .m_search { width: 44px; min-width: 44px; } .l_header .m_search input::placeholder { opacity: 0; -webkit-opacity: 0; -moz-opacity: 0; } .l_header .m_search:hover { width: 240px; } .l_header .m_search:hover input::placeholder { opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } } @media screen and (min-width: 500px) { .l_header .m_search:hover .input { width: 100%; } .l_header .m_search:hover .input::placeholder { opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } } @media screen and (max-width: 500px) { .l_header .m_search { min-width: 0; } .l_header .m_search input::placeholder { opacity: 1; -webkit-opacity: 1; -moz-opacity: 1; } } .l_header .m_search .form { position: relative; display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; width: 100%; align-items: center; } .l_header .m_search .icon { position: absolute; width: 36px; left: 5px; color: var(--color-meta); } @media screen and (max-width: 500px) { .l_header .m_search .icon { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: none; } } .l_header .m_search .input { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: block; padding-top: 8px; padding-bottom: 8px; line-height: 1.3; width: 100%; color: var(--color-text); background: #fafafa; box-shadow: none; -webkit-box-shadow: none; box-sizing: border-box; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; padding-left: 40px; font-size: 0.875rem; border-radius: 8px; -webkit-border-radius: 8px; border: none; transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; } @media screen and (min-width: 500px) { .l_header .m_search .input:focus { box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1); -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1); } } @media screen and (max-width: 500px) { .l_header .m_search .input { background: var(--color-block); padding-left: 8px; border: none; } .l_header .m_search .input:hover, .l_header .m_search .input:focus { border: none; } } @media (max-width: 500px) { .l_header .m_search { left: 0; width: 0; overflow: hidden; position: absolute; background: #fff; transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; } .l_header .m_search .input { border-radius: 32px; -webkit-border-radius: 32px; margin-left: 16px; padding-left: 16px; } .l_header.z_search-open .m_search { width: 100%; } .l_header.z_search-open .m_search .input { width: calc(100% - 120px); } } ul.m-pc >li>a { color: inherit; border-bottom: 2px solid transparent; } ul.m-pc >li>a:active, ul.m-pc >li>a.active { border-bottom: 2px solid #3dd9b6; } ul.m-pc li:hover >ul.list-v, ul.list-v li:hover >ul.list-v { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: block; } ul.nav-list-h { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; align-items: stretch; } ul.nav-list-h>li { position: relative; justify-content: center; -webkit-justify-content: center; -khtml-justify-content: center; -moz-justify-content: center; -o-justify-content: center; -ms-justify-content: center; height: 100%; line-height: 2.4; border-radius: 4px; -webkit-border-radius: 4px; } ul.nav-list-h>li >a { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; font-weight: 600; } ul.list-v { z-index: 1; display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: none; position: absolute; background: var(--color-card); box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08); -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08); margin-top: -6px; border-radius: 4px; -webkit-border-radius: 4px; padding: 8px 0; } ul.list-v.show { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: block; } ul.list-v hr { margin-top: 8px; margin-bottom: 8px; } ul.list-v >li { white-space: nowrap; word-break: keep-all; } ul.list-v >li.header { font-size: 0.78125rem; font-weight: bold; line-height: 2em; color: var(--color-meta); margin: 8px 16px 4px; } ul.list-v >li.header i { margin-right: 8px; } ul.list-v >li ul { margin-left: 0; display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: none; margin-top: -40px; } ul.list-v .aplayer-container { min-height: 64px; padding: 6px 16px; } ul.list-v >li>a { transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: block; color: var(--color-list); font-size: 0.875rem; font-weight: bold; line-height: 36px; padding: 0 20px 0 16px; text-overflow: ellipsis; margin: 0 4px; border-radius: 4px; -webkit-border-radius: 4px; } @media screen and (max-width: 1024px) { ul.list-v >li>a { line-height: 40px; } } ul.list-v >li>a >i { margin-right: 8px; } ul.list-v >li>a:active, ul.list-v >li>a.active { color: var(--color-list-hl); } ul.list-v >li>a:hover { color: var(--color-list-hl); background: var(--color-site-bg); } .l_header .menu >ul>li>a { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: block; padding: 0 8px; } .l_header .menu >ul>li>a >i { margin-right: 4px; } .l_header ul.nav-list-h>li { color: var(--color-list); line-height: 64px; } .l_header ul.nav-list-h>li >a { max-height: 64px; overflow: hidden; color: inherit; } .l_header ul.nav-list-h>li >a:active, .l_header ul.nav-list-h>li >a.active { color: #3dd9b6; } .l_header ul.nav-list-h>li:hover>a { color: var(--color-list-hl); } .l_header ul.nav-list-h>li i.music { animation: rotate-effect 1.5s linear infinite; -webkit-animation: rotate-effect 1.5s linear infinite; -khtml-animation: rotate-effect 1.5s linear infinite; -moz-animation: rotate-effect 1.5s linear infinite; -o-animation: rotate-effect 1.5s linear infinite; -ms-animation: rotate-effect 1.5s linear infinite; } @-moz-keyframes rotate-effect { 0% { transform: rotate(0); -webkit-transform: rotate(0); -khtml-transform: rotate(0); -moz-transform: rotate(0); -o-transform: rotate(0); -ms-transform: rotate(0); } 25% { transform: rotate(90deg); -webkit-transform: rotate(90deg); -khtml-transform: rotate(90deg); -moz-transform: rotate(90deg); -o-transform: rotate(90deg); -ms-transform: rotate(90deg); } 50% { transform: rotate(180deg); -webkit-transform: rotate(180deg); -khtml-transform: rotate(180deg); -moz-transform: rotate(180deg); -o-transform: rotate(180deg); -ms-transform: rotate(180deg); } 75% { transform: rotate(270deg); -webkit-transform: rotate(270deg); -khtml-transform: rotate(270deg); -moz-transform: rotate(270deg); -o-transform: rotate(270deg); -ms-transform: rotate(270deg); } 100% { transform: rotate(360deg); -webkit-transform: rotate(360deg); -khtml-transform: rotate(360deg); -moz-transform: rotate(360deg); -o-transform: rotate(360deg); -ms-transform: rotate(360deg); } } @-webkit-keyframes rotate-effect { 0% { transform: rotate(0); -webkit-transform: rotate(0); -khtml-transform: rotate(0); -moz-transform: rotate(0); -o-transform: rotate(0); -ms-transform: rotate(0); } 25% { transform: rotate(90deg); -webkit-transform: rotate(90deg); -khtml-transform: rotate(90deg); -moz-transform: rotate(90deg); -o-transform: rotate(90deg); -ms-transform: rotate(90deg); } 50% { transform: rotate(180deg); -webkit-transform: rotate(180deg); -khtml-transform: rotate(180deg); -moz-transform: rotate(180deg); -o-transform: rotate(180deg); -ms-transform: rotate(180deg); } 75% { transform: rotate(270deg); -webkit-transform: rotate(270deg); -khtml-transform: rotate(270deg); -moz-transform: rotate(270deg); -o-transform: rotate(270deg); -ms-transform: rotate(270deg); } 100% { transform: rotate(360deg); -webkit-transform: rotate(360deg); -khtml-transform: rotate(360deg); -moz-transform: rotate(360deg); -o-transform: rotate(360deg); -ms-transform: rotate(360deg); } } @-o-keyframes rotate-effect { 0% { transform: rotate(0); -webkit-transform: rotate(0); -khtml-transform: rotate(0); -moz-transform: rotate(0); -o-transform: rotate(0); -ms-transform: rotate(0); } 25% { transform: rotate(90deg); -webkit-transform: rotate(90deg); -khtml-transform: rotate(90deg); -moz-transform: rotate(90deg); -o-transform: rotate(90deg); -ms-transform: rotate(90deg); } 50% { transform: rotate(180deg); -webkit-transform: rotate(180deg); -khtml-transform: rotate(180deg); -moz-transform: rotate(180deg); -o-transform: rotate(180deg); -ms-transform: rotate(180deg); } 75% { transform: rotate(270deg); -webkit-transform: rotate(270deg); -khtml-transform: rotate(270deg); -moz-transform: rotate(270deg); -o-transform: rotate(270deg); -ms-transform: rotate(270deg); } 100% { transform: rotate(360deg); -webkit-transform: rotate(360deg); -khtml-transform: rotate(360deg); -moz-transform: rotate(360deg); -o-transform: rotate(360deg); -ms-transform: rotate(360deg); } } @keyframes rotate-effect { 0% { transform: rotate(0); -webkit-transform: rotate(0); -khtml-transform: rotate(0); -moz-transform: rotate(0); -o-transform: rotate(0); -ms-transform: rotate(0); } 25% { transform: rotate(90deg); -webkit-transform: rotate(90deg); -khtml-transform: rotate(90deg); -moz-transform: rotate(90deg); -o-transform: rotate(90deg); -ms-transform: rotate(90deg); } 50% { transform: rotate(180deg); -webkit-transform: rotate(180deg); -khtml-transform: rotate(180deg); -moz-transform: rotate(180deg); -o-transform: rotate(180deg); -ms-transform: rotate(180deg); } 75% { transform: rotate(270deg); -webkit-transform: rotate(270deg); -khtml-transform: rotate(270deg); -moz-transform: rotate(270deg); -o-transform: rotate(270deg); -ms-transform: rotate(270deg); } 100% { transform: rotate(360deg); -webkit-transform: rotate(360deg); -khtml-transform: rotate(360deg); -moz-transform: rotate(360deg); -o-transform: rotate(360deg); -ms-transform: rotate(360deg); } } .menu-phone li ul.list-v { right: calc(100% - 0.5 * 16px); } .menu-phone li ul.list-v ul { right: calc(100% - 0.5 * 16px); } #wrapper { max-width: 1080px; margin: auto; } @media screen and (min-width: 2048px) { #wrapper { max-width: 55vw; } } #wrapper .menu { -webkit-box-flex: 1; -moz-box-flex: 1; -webkit-flex: 1 1; -ms-flex: 1 1; flex: 1 1; margin: 0 16px 0 0; } #wrapper .menu .list-v ul { left: calc(100% - 0.5 * 16px); } .menu-phone { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: none; margin-top: 16px; right: 8px; transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -khtml-transition: all 0.28s ease; -moz-transition: all 0.28s ease; -o-transition: all 0.28s ease; -ms-transition: all 0.28s ease; } .menu-phone ul { right: calc(100% - 0.5 * 16px); } @media screen and (max-width: 500px) { .menu-phone { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: block; } } .l_header { max-width: 65vw; left: calc((100% - 65vw) * 0.5); border-bottom-left-radius: 8px; border-bottom-right-radius: 8px; } @media screen and (max-width: 2048px) { .l_header { max-width: 1112px; left: calc((100% - 1112px) * 0.5); } } @media screen and (max-width: 1112px) { .l_header { left: 0; border-radius: 0; -webkit-border-radius: 0; max-width: 100%; } } @media screen and (max-width: 500px) { .l_header .container { margin-left: 0; margin-right: 0; } .l_header #wrapper .nav-main .title { padding-left: 16px; padding-right: 16px; } .l_header #wrapper .nav-sub { width: 100%; } .l_header #wrapper .nav-sub .title { overflow-y: scroll; margin-top: 2px; padding: 8px 16px; } .l_header #wrapper .switcher { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: -ms-flexbox /* TWEENER - IE 10 */; display: -webkit-flex /* NEW - Chrome */; display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */; display: flex; margin-right: 8px; } .l_header .menu { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: none; } } @media screen and (max-width: 500px) { .list-v li { max-width: 270px; } } #u-search { display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */; display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */; display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; padding: 60px 20px; z-index: 1001; } @media screen and (max-width: 680px) { #u-search { padding: 0px; } } if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode)) document.write( ''+ 'html{'+ 'overflow-x: hidden !important;'+ 'overflow-y: hidden !important;'+ '}'+ '.kill-ie{'+ 'text-align:center;'+ 'height: 100%;'+ 'margin-top: 15%;'+ 'margin-bottom: 5500%;'+ '}'+ '.kill-t{'+ 'font-size: 2rem;'+ '}'+ '.kill-c{'+ 'font-size: 1.2rem;'+ '}'+ '#l_header,#l_body{'+ 'display: none;'+ '}'+ ''+ ''+ `抱歉，您的浏览器无法访问本站`+ `微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。`+ `了解详情 >`+ ''); html{ overflow-x: hidden !important; overflow-y: hidden !important; } .kill-noscript{ text-align:center; height: 100%; margin-top: 15%; margin-bottom: 5500%; } .kill-t{ font-size: 2rem; } .kill-c{ font-size: 1.2rem; } #l_header,#l_body{ display: none; } 抱歉，您的浏览器无法访问本站 本页面需要浏览器支持（启用）JavaScript 了解详情 > /************这个文件存放不需要重载的全局变量和全局函数*********/ window.volantis = {}; // volantis 全局变量 volantis.debug = false; // 开启调试模式 volantis.dom = {}; // 页面Dom see: /source/js/app.js etc. volantis.GLOBAL_CONFIG ={ debug: false, cdn: {\"js\":{\"app\":\"/js/app.af2d54c8.js\",\"parallax\":\"/js/plugins/parallax.8bf0ab10.js\",\"rightMenu\":\"/js/plugins/rightMenu.d9437285.js\",\"rightMenus\":\"/js/plugins/rightMenus.1aa99ff1.js\",\"sites\":\"/js/plugins/tags/sites.76bf19b8.js\",\"friends\":\"/js/plugins/tags/friends.f372da57.js\",\"contributors\":\"/js/plugins/tags/contributors.aec80453.js\",\"search\":\"/js/search/hexo.0e52f222.js\"},\"css\":{\"style\":\"/css/style.8593fb4d.css\"}}, default: {\"avatar\":\"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg\",\"link\":\"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/link/8f277b4ee0ecd.svg\",\"cover\":\"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg\",\"image\":\"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/image/2659360.svg\"}, lastupdate: new Date(1659073873548), sidebar: { for_page: [\"blogger\",\"category\",\"tagcloud\",\"donate\"], for_post: [\"toc\"], webinfo: { lastupd: { enable: true, friendlyShow: true }, runtime: { data: \"2020/01/01\", unit: \"天\" } } }, plugins: { message: {\"enable\":true,\"css\":\"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/css/iziToast.min.css\",\"js\":\"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/js/iziToast.min.js\",\"icon\":{\"default\":\"fa-solid fa-info-circle light-blue\",\"quection\":\"fa-solid fa-question-circle light-blue\"},\"time\":{\"default\":5000,\"quection\":20000},\"position\":\"topRight\",\"transitionIn\":\"bounceInLeft\",\"transitionOut\":\"fadeOutRight\",\"titleColor\":\"var(--color-text)\",\"messageColor\":\"var(--color-text)\",\"backgroundColor\":\"var(--color-card)\",\"zindex\":2147483647,\"copyright\":{\"enable\":true,\"title\":\"知识共享许可协议\",\"message\":\"请遵守 CC BY-NC-SA 4.0 协议。\",\"icon\":\"far fa-copyright light-blue\"},\"aplayer\":{\"enable\":true,\"play\":\"fa-solid fa-play\",\"pause\":\"fa-solid fa-pause\"},\"rightmenu\":{\"enable\":true,\"notice\":true}}, fancybox: {\"css\":\"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.css\",\"js\":\"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.umd.js\"}, } } /******************** volantis.EventListener ********************************/ // 事件监听器 see: /source/js/app.js volantis.EventListener = {} // 这里存放pjax切换页面时将被移除的事件监听器 volantis.EventListener.list = [] //构造方法 function volantisEventListener(type, f, ele) { this.type = type this.f = f this.ele = ele } // 移除事件监听器 volantis.EventListener.remove = () => { volantis.EventListener.list.forEach(function (i) { i.ele.removeEventListener(i.type, i.f, false) }) volantis.EventListener.list = [] } /******************** volantis.dom.$ ********************************/ // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API function volantisDom(ele) { if (!ele) ele = document.createElement(\"div\") this.ele = ele; // ============================================================== this.ele.find = (c) => { let q = this.ele.querySelector(c) if (q) return new volantisDom(q) } // ============================================================== this.ele.hasClass = (c) => { return this.ele.className.match(new RegExp('(\\\\s|^)' + c + '(\\\\s|$)')); } this.ele.addClass = (c) => { this.ele.classList.add(c); return this.ele } this.ele.removeClass = (c) => { this.ele.classList.remove(c); return this.ele } this.ele.toggleClass = (c) => { if (this.ele.hasClass(c)) { this.ele.removeClass(c) } else { this.ele.addClass(c) } return this.ele } // ============================================================== // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除 this.ele.on = (c, f, r = 1) => { this.ele.addEventListener(c, f, false) if (r) { volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele)) } return this.ele } this.ele.click = (f, r) => { this.ele.on(\"click\", f, r) return this.ele } this.ele.scroll = (f, r) => { this.ele.on(\"scroll\", f, r) return this.ele } // ============================================================== this.ele.html = (c) => { // if(c=== undefined){ // return this.ele.innerHTML // }else{ this.ele.innerHTML = c return this.ele // } } // ============================================================== this.ele.hide = (c) => { this.ele.style.display = \"none\" return this.ele } this.ele.show = (c) => { this.ele.style.display = \"block\" return this.ele } // ============================================================== return this.ele } volantis.dom.$ = (ele) => { return !!ele ? new volantisDom(ele) : null; } /******************** RunItem ********************************/ function RunItem() { this.list = []; // 存放回调函数 this.start = () => { for (var i = 0; i < this.list.length; i++) { this.list[i].run(); } }; this.push = (fn, name, setRequestAnimationFrame = true) => { let myfn = fn if (setRequestAnimationFrame) { myfn = ()=>{ volantis.requestAnimationFrame(fn) } } var f = new Item(myfn, name); this.list.push(f); }; this.remove = (name) =>{ for (let index = 0; index < this.list.length; index++) { const e = this.list[index]; if (e.name == name) { this.list.splice(index,1); } } } // 构造一个可以run的对象 function Item(fn, name) { // 函数名称 this.name = name || fn.name; // run方法 this.run = () => { try { fn() } catch (error) { console.log(error); } }; } } /******************** Pjax ********************************/ // /layout/_plugins/pjax/index.ejs // volantis.pjax.send(callBack[,\"callBackName\"]) 传入pjax:send回调函数 // volantis.pjax.push(callBack[,\"callBackName\"]) 传入pjax:complete回调函数 // volantis.pjax.error(callBack[,\"callBackName\"]) 传入pjax:error回调函数 volantis.pjax = {}; volantis.pjax.method = { complete: new RunItem(), error: new RunItem(), send: new RunItem(), }; volantis.pjax = Object.assign(volantis.pjax, { push: volantis.pjax.method.complete.push, error: volantis.pjax.method.error.push, send: volantis.pjax.method.send.push, }); /******************** RightMenu ********************************/ // volantis.rightmenu.handle(callBack[,\"callBackName\"]) 外部菜单项控制 // 可在 volantis.mouseEvent 处获取右键事件 volantis.rightmenu = {}; volantis.rightmenu.method = { handle: new RunItem(), } volantis.rightmenu = Object.assign(volantis.rightmenu, { handle: volantis.rightmenu.method.handle.push, }); /******************** Dark Mode ********************************/ // /layout/_partial/scripts/darkmode.ejs // volantis.dark.mode 当前模式 dark or light // volantis.dark.toggle() 暗黑模式触发器 // volantis.dark.push(callBack[,\"callBackName\"]) 传入触发器回调函数 volantis.dark = {}; volantis.dark.method = { toggle: new RunItem(), }; volantis.dark = Object.assign(volantis.dark, { push: volantis.dark.method.toggle.push, }); /******************** Message ********************************/ // VolantisApp.message /******************** isMobile ********************************/ // /source/js/app.js // volantis.isMobile // volantis.isMobileOld /********************脚本动态加载函数********************************/ // volantis.js(src, cb) cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js(\"src\", ()=>{}) 或 volantis.js(\"src\", {defer:true,onload:()=>{}}) // volantis.css(src) // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载 // (async () => { // await volantis.js(\"...theme.plugins.aplayer.js.aplayer...\") // await volantis.js(\"...theme.plugins.aplayer.js.meting...\") // })(); // 已经加入了setTimeout volantis.js = (src, cb) => { return new Promise(resolve => { setTimeout(function () { var HEAD = document.getElementsByTagName(\"head\")[0] || document.documentElement; var script = document.createElement(\"script\"); script.setAttribute(\"type\", \"text/javascript\"); if (cb) { if (JSON.stringify(cb)) { for (let p in cb) { if (p == \"onload\") { script[p] = () => { cb[p]() resolve() } } else { script[p] = cb[p] script.onload = resolve } } } else { script.onload = () => { cb() resolve() }; } } else { script.onload = resolve } script.setAttribute(\"src\", src); HEAD.appendChild(script); }); }); } volantis.css = (src) => { return new Promise(resolve => { setTimeout(function () { var link = document.createElement('link'); link.rel = \"stylesheet\"; link.href = src; link.onload = resolve; document.getElementsByTagName(\"head\")[0].appendChild(link); }); }); } /********************按需加载的插件********************************/ // volantis.import.jQuery().then(()=>{}) volantis.import = { jQuery: () => { if (typeof jQuery == \"undefined\") { return volantis.js(\"https://unpkg.com/volantis-static@0.0.1654736714924/libs/jquery/dist/jquery.min.js\") } else { return new Promise(resolve => { resolve() }); } } } /********************** requestAnimationFrame ********************************/ // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。 // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。 volantis.requestAnimationFrame = (fn)=>{ if (!window.requestAnimationFrame) { window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame; } window.requestAnimationFrame(fn) } /************************ layoutHelper *****************************************/ volantis.layoutHelper = (helper, html, opt)=>{ opt = Object.assign({clean:false, pjax:true}, opt) function myhelper(helper, html, clean) { volantis.tempDiv = document.createElement(\"div\"); volantis.tempDiv.innerHTML = html; let layoutHelper = document.querySelector(\"#layoutHelper-\"+helper) if (layoutHelper) { if (clean) { layoutHelper.innerHTML = \"\" } layoutHelper.append(volantis.tempDiv); } } myhelper(helper, html, opt.clean) if (opt.pjax) { volantis.pjax.push(()=>{ myhelper(helper, html, opt.clean) },\"layoutHelper-\"+helper) } } /****************************** 滚动事件处理 ****************************************/ volantis.scroll = { engine: new RunItem(), unengine: new RunItem(), }; volantis.scroll = Object.assign(volantis.scroll, { push: volantis.scroll.engine.push, }); // 滚动条距离顶部的距离 volantis.scroll.getScrollTop = () =>{ let scrollPos; if (window.pageYOffset) { scrollPos = window.pageYOffset; } else if (document.compatMode && document.compatMode != 'BackCompat') { scrollPos = document.documentElement.scrollTop; } else if (document.body) { scrollPos = document.body.scrollTop; } return scrollPos; } // 使用 requestAnimationFrame 处理滚动事件 // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动. volantis.scroll.handleScrollEvents = () => { volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop() function loop() { const scrollTop = volantis.scroll.getScrollTop(); if (volantis.scroll.lastScrollTop !== scrollTop) { volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop; volantis.scroll.lastScrollTop = scrollTop; // if (volantis.scroll.del > 0) { // console.log(\"向下滚动\"); // } else { // console.log(\"向上滚动\"); // } // 注销过期的unengine未滚动事件 volantis.scroll.unengine.list=[] volantis.scroll.engine.start(); }else{ volantis.scroll.unengine.start(); } volantis.requestAnimationFrame(loop) } volantis.requestAnimationFrame(loop) } volantis.scroll.handleScrollEvents() // 触发页面滚动至目标元素位置 volantis.scroll.to = (ele, option = {}) =>{ // 默认配置 opt = { top: ele.getBoundingClientRect().top + document.documentElement.scrollTop, behavior: \"smooth\" } // 定义配置 if (\"top\" in option) { opt.top = option.top } if (\"behavior\" in option) { opt.behavior = option.behavior } if (\"addTop\" in option) { opt.top += option.addTop } if (!(\"observerDic\" in option)) { option.observerDic = 100 } // 滚动 window.scrollTo(opt); // 监视器 // 监视并矫正元素滚动到指定位置 // 用于处理 lazyload 引起的 cls 导致的定位失败问题 // option.observer = false if (option.observer) { setTimeout(()=>{ volantis.scroll.unengine.push(()=>{ let me = ele.getBoundingClientRect().top if(!(me >= -option.observerDic && me { if (document.querySelector(\".post-story\")) { console.log(\"cleanContentVisibility\"); document.querySelectorAll(\".post-story\").forEach(e=>{ e.classList.remove(\"post-story\") }) } } /******************************************************************************/ /******************************************************************************/ /******************************************************************************/ //图像加载出错时的处理 function errorImgAvatar(img) { img.src = \"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg\"; img.onerror = null; } function errorImgCover(img) { img.src = \"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg\"; img.onerror = null; } /******************************************************************************/ 博客 分类 标签 归档 友链 关于 博客 分类 标签 归档 友链 关于 迷途的小窝 文档 帮助 示例 社区 博客 categories 请设置文章作者 发布于：2022年7月27日 更新于：2022年7月29日 评论 window.pdata={} pdata.ispage=false; pdata.commentPath=\"\"; pdata.commentPlaceholder=\"\"; pdata.commentConfig={}; // see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs // header var l_header=document.getElementById(\"l_header\"); l_header.classList.add(\"show\"); // cover var cover_wrapper=document.querySelector('#l_cover .cover-wrapper'); var scroll_down=document.getElementById('scroll-down'); cover_wrapper.id=\"none\"; cover_wrapper.style.display=\"none\"; scroll_down.style.display=\"none\"; 博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议 本站总访问量为 次 访客数为 人 本站使用 Volantis 作为主题 [Copyright © 迷途] /******************** volantis.dom ********************************/ // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc. volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById(\"safearea\")); // 页面主体 volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上 volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏 volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个 volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮 移动端 1个 volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏 volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个 volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); // 手机端 子菜单 多个 volantis.css(\"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fortawesome/fontawesome-free/css/all.min.css\"); function loadIssuesJS() { const sites_api = document.getElementById('sites-api'); if (sites_api != undefined && typeof SitesJS === 'undefined') { volantis.js(\"/js/plugins/tags/sites.76bf19b8.js\") } const friends_api = document.getElementById('friends-api'); if (friends_api != undefined && typeof FriendsJS === 'undefined') { volantis.js(\"/js/plugins/tags/friends.f372da57.js\") } const contributors_api = document.getElementById('contributors-api'); if (contributors_api != undefined && typeof ContributorsJS === 'undefined') { volantis.js(\"/js/plugins/tags/contributors.aec80453.js\") } }; loadIssuesJS() volantis.pjax.push(()=>{ loadIssuesJS(); }) // https://www.npmjs.com/package/vanilla-lazyload // Set the options globally // to make LazyLoad self-initialize window.lazyLoadOptions = { elements_selector: \".lazyload\", threshold: 0 }; // Listen to the initialization event // and get the instance of LazyLoad window.addEventListener( \"LazyLoad::Initialized\", function (event) { window.lazyLoadInstance = event.detail.instance; }, false ); document.addEventListener('DOMContentLoaded', function () { lazyLoadInstance.update(); }); document.addEventListener('pjax:complete', function () { lazyLoadInstance.update(); }); window.FPConfig = { delay: 0, ignoreKeywords: [\"#\"], maxRPS: 6, hoverDelay: 0 }; function pjax_scrollrebeal() { ScrollReveal().reveal(\"#l_main .reveal\", { distance: \"32px\", duration: \"800\", interval: \"20\", scale: \"1\", easing: \"ease-out\", }); } function init_scrollrebeal() { if (typeof ScrollReveal == \"undefined\") { volantis.requestAnimationFrame(init_scrollrebeal); } else { pjax_scrollrebeal(); } } volantis.js(\"https://unpkg.com/volantis-static@0.0.1654736714924/libs/scrollreveal/dist/scrollreveal.min.js\"); document.addEventListener(\"DOMContentLoaded\", init_scrollrebeal); volantis.pjax.push( pjax_scrollrebeal, \"pjax_scrollrebeal\", (setRequestAnimationFrame = false) ); volantis.layoutHelper(\"comments\",``) volantis.giscus = {}; function check_giscus() { if (volantis.dark.mode === \"dark\") { volantis.giscus.Theme = 'dark'; } else { volantis.giscus.Theme = 'light'; } return document.getElementById(\"giscus_container\"); } function pjax_giscus() { const HEAD = check_giscus(); if (!HEAD) return; let cfg = Object.assign({\"theme\":{\"light\":\"light\",\"dark\":\"dark\"}},pdata.commentConfig) const script = document.createElement('script'); script.setAttribute('src', 'https://giscus.app/client.js'); Object.keys(cfg).forEach(k=>{ if (k != \"theme\") { script.setAttribute('data-'+k, cfg[k]); } }) script.setAttribute('data-theme', volantis.giscus.Theme); script.setAttribute('crossorigin', \"anonymous\"); HEAD.appendChild(script); } function dark_giscus() { const HEAD = check_giscus(); if (!HEAD) return; const message = { setConfig: { theme: volantis.giscus.Theme } }; const giscusIframe = document.querySelector('iframe.giscus-frame'); giscusIframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app'); } pjax_giscus(); volantis.pjax.push(pjax_giscus); volantis.dark.push(dark_giscus); const SearchServiceDataPathRoot = (\"/\" || \"/\").endsWith(\"/\") ? \"/\" || \"/\" : \"//\" || \"/\"; const SearchServiceDataPath = SearchServiceDataPathRoot + \"content.json\"; function loadSearchScript() { // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs return volantis.js(\"/js/search/hexo.0e52f222.js\"); } function loadSearchService() { loadSearchScript(); document.querySelectorAll(\".input.u-search-input\").forEach((e) => { e.removeEventListener(\"focus\", loadSearchService, false); }); document.querySelectorAll(\".u-search-form\").forEach((e) => { e.addEventListener(\"submit\", (event) => { event.preventDefault(); }, false); }); } // 打开并搜索 字符串 s function OpenSearch(s) { if (typeof SearchService === 'undefined') loadSearchScript().then(() => { SearchService.setQueryText(s); SearchService.search(); }); else { SearchService.setQueryText(s); SearchService.search(); } } // 访问含有 ?s=xxx 的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js if (window.location.search && /^\\?s=/g.test(window.location.search)) { let queryText = decodeURI(window.location.search) .replace(/\\ /g, \"-\") .replace(/^\\?s=/g, \"\"); OpenSearch(queryText); } // 搜索输入框获取焦点时加载搜索 document.querySelectorAll(\".input.u-search-input\").forEach((e) => { e.addEventListener(\"focus\", loadSearchService, false); }); function pjax_highlightjs_copyCode(){ if (!(document.querySelector(\".highlight .code pre\") || document.querySelector(\".article pre code\"))) { return; } VolantisApp.utilCopyCode(\".highlight .code pre, .article pre code\") } volantis.requestAnimationFrame(pjax_highlightjs_copyCode) volantis.pjax.push(pjax_highlightjs_copyCode) function load_swiper() { if (!document.querySelectorAll(\".swiper-container\")[0]) return; volantis.css(\"https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.css\"); volantis.js(\"https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.js\").then(() => { pjax_swiper(); }); } load_swiper(); function pjax_swiper() { volantis.swiper = new Swiper('.swiper-container', { slidesPerView: 'auto', spaceBetween: 8, centeredSlides: true, loop: true, pagination: { el: '.swiper-pagination', clickable: true, }, navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, }); } volantis.pjax.push(() => { if (!document.querySelectorAll(\".swiper-container\")[0]) return; if (typeof volantis.swiper === \"undefined\") { load_swiper(); } else { pjax_swiper(); } }); function listennSidebarTOC() { const navItems = document.querySelectorAll(\".toc li\"); if (!navItems.length) return; let targets = [] const sections = [...navItems].map((element) => { const link = element.querySelector(\".toc-link\"); const target = document.getElementById( decodeURI(link.getAttribute(\"href\")).replace(\"#\", \"\") ); targets.push(target) // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位??? link.setAttribute(\"onclick\",\"return false;\") link.setAttribute(\"toc-action\",\"toc-\"+decodeURI(link.getAttribute(\"href\")).replace(\"#\", \"\")) link.setAttribute(\"href\",\"/\") // 配置 点击 触发新的锚点定位 link.addEventListener(\"click\", (event) => { event.preventDefault(); // 这里的 addTop 是通过错位使得 toc 自动展开. volantis.scroll.to(target,{addTop: 5, observer:true}) // Anchor id history.pushState(null, document.title, \"#\" + target.id); }); return target; }); function activateNavByIndex(target) { if (target.classList.contains(\"active-current\")) return; document.querySelectorAll(\".toc .active\").forEach((element) => { element.classList.remove(\"active\", \"active-current\"); }); target.classList.add(\"active\", \"active-current\"); let parent = target.parentNode; while (!parent.matches(\".toc\")) { if (parent.matches(\"li\")) parent.classList.add(\"active\"); parent = parent.parentNode; } } // 方案一： volantis.activateNavIndex=0 activateNavByIndex(navItems[volantis.activateNavIndex]) volantis.scroll.push(()=>{ if (targets[0].getBoundingClientRect().top >= 0) { volantis.activateNavIndex = 0 }else if (targets[targets.length-1].getBoundingClientRect().top < 0) { volantis.activateNavIndex = targets.length-1 } else { for (let index = 0; index < targets.length; index++) { const target0 = targets[index]; const target1 = targets[(index+1)%targets.length]; if (target0.getBoundingClientRect().top < 0&&target1.getBoundingClientRect().top >= 0) { volantis.activateNavIndex=index break; } } } activateNavByIndex(navItems[volantis.activateNavIndex]) }) // 方案二： // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的 // function findIndex(entries) { // let index = 0; // let entry = entries[index]; // if (entry.boundingClientRect.top > 0) { // index = sections.indexOf(entry.target); // return index === 0 ? 0 : index - 1; // } // for (; index < entries.length; index++) { // if (entries[index].boundingClientRect.top { // let scrollHeight = document.documentElement.scrollHeight; // if (scrollHeight > marginTop) { // observe.disconnect(); // createIntersectionObserver(scrollHeight); // return; // } // let index = findIndex(entries); // activateNavByIndex(navItems[index]); // }, { // rootMargin: marginTop + \"px 0px -100% 0px\", // threshold: 0, // } // ); // sections.forEach((element) => { // element && intersectionObserver.observe(element); // }); // } // createIntersectionObserver(document.documentElement.scrollHeight); } document.addEventListener(\"DOMContentLoaded\", ()=>{ volantis.requestAnimationFrame(listennSidebarTOC) }); document.addEventListener(\"pjax:success\", ()=>{ volantis.requestAnimationFrame(listennSidebarTOC) }); try { // https://web.dev/content-visibility/ // https://www.caniuse.com/?search=content-visibility // https://infrequently.org/2020/12/content-visibility-scroll-fix/ // https://infrequently.org/2020/12/resize-resilient-deferred-rendering/ // 备注 目前已知的问题: // 动态修改导致的内容高度变化(例如评论框异步渲染的外部盒子高度变化) 无法提前获知, 进而导致的首次滚动条跳动无法去除 (wontfix) 事实上不使用 content-visibility 也会有跳动, 不过是比使用 content-visibility 跳动提前 // scrollreveal 插件潜在问题 目前尚不明确 let eqIsh = (a, b, fuzz = 2) => { return Math.abs(a - b) { return !eqIsh(a.width, b.width) || !eqIsh(a.height, b.height); }; // Keep a map of elements and the dimensions of // their place-holders, re-setting the element's // intrinsic size when we get updated measurements // from observers. let spaced = new WeakMap(); // Only call this when known cheap, post layout let reserveSpace = (el, rect = el.getClientBoundingRect()) => { let old = spaced.get(el); // Set intrinsic size to prevent jumping on un-painting: // https://drafts.csswg.org/css-sizing-4/#intrinsic-size-override if (!old || rectNotEQ(old, rect)) { spaced.set(el, rect); el.style[\"contain-intrinsic-size\"] = `${rect.width}px ${rect.height}px`; } }; let iObs = new IntersectionObserver( (entries, o) => { entries.forEach((entry) => { // We don't care if the element is intersecting or // has been laid out as our page structure ensures // they'll get the right width. reserveSpace(entry.target, entry.boundingClientRect); }); }, { rootMargin: \"500px 0px 500px 0px\" } ); let rObs = new ResizeObserver((entries, o) => { entries.forEach((entry) => { reserveSpace(entry.target, entry.contentRect); }); }); let resizeResilientDeferredRendering = (Selector) => { let articles = document.querySelectorAll(Selector); if (articles.length) { articles.forEach((el) => { iObs.observe(el); rObs.observe(el); }); // Workaround for Chrome bug, part 2. // // Re-enable browser management of rendering for the // first article after the first paint. Double-rAF // to ensure we get called after a layout. requestAnimationFrame(() => { requestAnimationFrame(() => { articles[0].style[\"content-visibility\"] = \"auto\"; }); }); } }; let contentVisibilityScrollFix = () => { if (!(\"content-visibility\" in document.documentElement.style)) { return; } resizeResilientDeferredRendering(\".post-story\"); }; contentVisibilityScrollFix(); volantis.pjax.push(contentVisibilityScrollFix); } catch (error) { console.log(error); } document.onreadystatechange = function () { if (document.readyState == 'complete') { // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式 const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {} if (getComputedStyle(document.querySelector(\"#safearea\"), null)[\"display\"] == \"none\" || saveData || /2g/.test(effectiveType)) { document.querySelectorAll(\".reveal\").forEach(function (e) { e.style[\"opacity\"] = \"1\"; }); document.querySelector(\"#safearea\").style[\"display\"] = \"block\"; } } } [{\"@context\":\"http://schema.org\",\"@type\":\"Organization\",\"name\":\"迷途\",\"url\":\"http://example.com/\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png\",\"width\":192,\"height\":192}},{\"@context\":\"http://schema.org\",\"@type\":\"Person\",\"name\":\"迷途\",\"image\":{\"@type\":\"ImageObject\",\"url\":\"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png\"},\"url\":\"http://example.com/\",\"sameAs\":[\"https://github.com/volantis-x\"],\"description\":\"https://wenchengz.cn\"},{\"@context\":\"http://schema.org\",\"@type\":\"BreadcrumbList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"@id\":\"http://example.com/\",\"name\":\"迷途\"}}]},{\"@context\":\"http://schema.org\",\"@type\":\"WebSite\",\"name\":\"迷途\",\"url\":\"http://example.com/\",\"keywords\":null,\"description\":\"https://wenchengz.cn\",\"author\":{\"@type\":\"Person\",\"name\":\"迷途\",\"image\":{\"@type\":\"ImageObject\",\"url\":\"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png\"},\"url\":\"http://example.com/\",\"description\":\"https://wenchengz.cn\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"迷途\",\"url\":\"http://example.com/\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png\",\"width\":192,\"height\":192}},\"potentialAction\":{\"@type\":\"SearchAction\",\"name\":\"Site Search\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"http://example.com?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}},{\"@context\":\"http://schema.org\",\"@type\":\"BlogPosting\",\"headline\":\"categories\",\"description\":\"https://wenchengz.cn\",\"inLanguage\":\"zh-CN\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"http://example.com/categories/index.html\"},\"author\":{\"@type\":\"Person\",\"name\":\"迷途\",\"image\":{\"@type\":\"ImageObject\",\"url\":\"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png\"},\"url\":\"http://example.com/\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"迷途\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png\",\"width\":192,\"height\":192}},\"url\":\"http://example.com/categories/index.html\",\"wordCount\":0,\"datePublished\":\"2022-07-27T09:30:39.000Z\",\"dateModified\":\"2022-07-29T04:37:35.583Z\",\"image\":{\"@type\":\"ImageObject\",\"url\":\"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png\",\"width\":192,\"height\":192}}] var pjax; document.addEventListener('DOMContentLoaded', function () { pjax = new Pjax({ elements: 'a[href]:not([href^=\"#\"]):not([href=\"javascript:void(0)\"]):not([pjax-fancybox]):not([onclick=\"return false;\"]):not([onclick=\"return!1\"]):not([target=\"_blank\"]):not([target=\"view_window\"]):not([href$=\".xml\"])', selectors: [ \"head title\", \"head meta[name=keywords]\", \"head meta[name=description]\", \"#l_main\", \"#pjax-header-nav-list\", \".pjax\", \"pjax\", // 标签 \"script[data-pjax], .pjax-reload script\" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载 ], cacheBust: false, // url 地址追加时间戳，用以避免浏览器缓存 timeout: 5000, }); }); document.addEventListener('pjax:send', function (e) { //window.stop(); // 相当于点击了浏览器的停止按钮 try { var currentUrl = window.location.pathname; var targetUrl = e.triggerElement.href; var banUrl = [\"\"]; if (banUrl[0] != \"\") { banUrl.forEach(item => { if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) { window.location.href = targetUrl; } }); } } catch (error) {} // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs volantis.pjax.method.send.start(); }); document.addEventListener('pjax:complete', function () { // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs volantis.pjax.method.complete.start(); }); document.addEventListener('pjax:error', function (e) { if(volantis.debug) { console.error(e); console.log('pjax error: \\n' + JSON.stringify(e)); }else{ // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs volantis.pjax.method.error.start(); window.location.href = e.triggerElement.href; } });"}],"posts":[{"title":"ros2笔记","slug":"ros2","date":"2022-07-28T15:43:08.000Z","updated":"2022-07-31T10:35:49.820Z","comments":true,"path":"2022/07/28/ros2/","link":"","permalink":"http://example.com/2022/07/28/ros2/","excerpt":"","text":"ros2基础ros2节点通过节点查看节点信息 运行节点 ros2 run 包名 节点名 查看节点列表 ros2 node list 查看节点信息 ros2 node info 节点名 重映射节点 ros2 run turtlesim turtlesim_node –ros-args –remap __node:&#x3D;my_turtle 功能包12mkdir -p ./srcsudo apt install ros-foxy-包名 相关指令 创建功能包ros2 pkg create 包名 –build-type {cmake,ament_cmake,ament_python} –dependencies &lt;依赖名字&gt; 列出可执行文件 ros2 pkg 包名 功能包名 列出所有的包 ros2 pkg list 输出包所在路径前缀 ros2 pkg prefix 包名 colcon编译 全部编译 source install&#x2F;setup.bash 编译一个包 colcon build –packages-select 包名 ros2 pkg create village_li 需间隔两个空 –build-type ament_python –dependencies rclpy ros2 pkg list | grep vill 将包含vill的结果输出 使用c++编写创建功能包 &#x3D;&#x3D;ros2 pkg create village_wang –dependencies rclcpp&#x3D;&#x3D; 编写代码 123456789101112131415161718192021// &quot;&quot;&quot; // 1. 导入库文件// 2. 初始化客户端库// 3. 新建节点// 4. spin循环节点// 5. 关闭客户端库// &quot;&quot;&quot;#include &quot;rclcpp/rclcpp.hpp&quot;int main(int argc, char *argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;rclcpp::Node&gt;(&quot;wang2&quot;); RCLCPP_INFO(node-&gt;get_logger(),&quot;大家好，我是单身沟王而&quot;); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 修改cmakelist文件 1234567add_executable(wang2_node src/wang2_pop.cpp)ament_target_dependencies(wang2_node rclcpp)install(TARGETS wang2_node DESTINATION lib/$&#123;PROJECT_NAME&#125;) 编译运行节点 12colcon buildros2 run village_wang wang2_node 使用python编写1234567891011121314151617181920import rclpyfrom rclpy.node import Node# &quot;&quot;&quot; # 1. 导入库文件# 2. 初始化客户端库# 3. 新建节点# 4. spin循环节点# 5. 关闭客户端库# &quot;&quot;&quot;def main(args=None): # 入口函数 # 2. 初始化客户端库 rclpy.init(args=args) # 3. 新建节点 li4_node = WriteNode(&quot;li4&quot;) # li4_node.get_logger().info(&quot;大家好,我是作家li4&quot;) rclpy.spin(li4_node) rclpy.shutdown 话题介绍常用命令 ros2 topic list 返回系统中当前活动的所有主题的列表 ros2 topic list -t 增加消息类型 ros2 topic echo &#x2F;chatter 打印实时话题内容 ros2 topic info &#x2F;chatter 查看主题信息 ros2 interface show std_msgs&#x2F;msg&#x2F;String 查看消息类型 ros2 topic pub &#x2F;chatter std_msgs&#x2F;msg&#x2F;String ‘data: “123”‘ 手动发布命令 python12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# import rclpy# from rclpy.node import Node# &quot;&quot;&quot; # 1. 导入库文件# 2. 初始化客户端库# 3. 新建节点# 4. spin循环节点# 5. 关闭客户端库# &quot;&quot;&quot;# def main(args=None):# # 入口函数# # 2. 初始化客户端库# rclpy.init(args=args)# # 3. 新建节点# li4_node = Node(&quot;li4&quot;)# li4_node.get_logger().info(&quot;大家好,我是作家li4&quot;)# rclpy.spin(li4_node)# rclpy.shutdownimport rclpyfrom rclpy.node import Nodefrom std_msgs.msg import String,UInt32&quot;&quot;&quot; 导入消息类型 声明并创建发布者 编写发布者逻辑发布数据 &quot;&quot;&quot;&quot;&quot;&quot; 1. 导入库文件 2. 初始化客户端库 3. 新建节点 4. spin循环节点 5. 关闭客户端库 &quot;&quot;&quot;class WriteNode(Node): def __init__(self,name): super().__init__(name) self.get_logger().info(&quot;大家好，我是作家%s&quot; % name) # 声明并创建发布者 self.pub_novel = self.create_publisher(String,&quot;sexy_girl&quot;,10) self.count = 0 self.timer_period = 5 self.timer = self.create_timer(self.timer_period,self.timer_callback) self.account = 80 self.sub_money = self.create_subscription(UInt32,&quot;sexy_girl_money&quot;,self.recv_money_callback,10) def timer_callback(self): msg = String() msg.data = &quot;年此外%d&quot; % self.count self.pub_novel.publish(msg) self.get_logger().info(&quot;发布了一个消息%s&quot; % msg.data) self.count +=1 def recv_money_callback(self,money): self.account += money.data self.get_logger().info(&quot;收到%d的稿费，现在账户里有%d的钱&quot; % (money.data,self.account))def main(args=None): # 入口函数 # 2. 初始化客户端库 rclpy.init(args=args) # 3. 新建节点 li4_node = WriteNode(&quot;li4&quot;) # li4_node.get_logger().info(&quot;大家好,我是作家li4&quot;) rclpy.spin(li4_node) rclpy.shutdown c++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// &quot;&quot;&quot; // 1. 导入库文件// 2. 初始化客户端库// 3. 新建节点// 4. spin循环节点// 5. 关闭客户端库// &quot;&quot;&quot;#include &quot;rclcpp/rclcpp.hpp&quot;// // 导入消息类型#include &quot;std_msgs/msg/string.hpp&quot;// 导入发布者的消息接口类型#include &quot;std_msgs/msg/u_int32.hpp&quot;using std::placeholders::_1;using std::placeholders::_2;class SingleDogNode: public rclcpp::Node&#123;private: /* data */ // /声明订阅者 rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr sub_novel; // 声明话题发布者 rclcpp::Publisher&lt;std_msgs::msg::UInt32&gt;::SharedPtr pub_money; // 创建回调函数 void novel_callback(const std_msgs::msg::String::SharedPtr novels)&#123; // 编写发布逻辑发布数据 std_msgs::msg::UInt32 money; money.data = 10; pub_money-&gt;publish(money); //编写回调处理逻辑 RCLCPP_INFO(this-&gt;get_logger(),&quot;已阅%s&quot;,novels-&gt;data.c_str()); &#125;public: SingleDogNode(std::string name):Node(name) &#123; RCLCPP_INFO(this-&gt;get_logger(),&quot;大家好，我是单身沟%s&quot;,name.c_str()); //3.创建订阅者 sub_novel = this-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;sexy_girl&quot;,10,std::bind(&amp;SingleDogNode::novel_callback,this,_1)); // 创建话题发布者 pub_money = this-&gt;create_publisher&lt;std_msgs::msg::UInt32&gt;(&quot;sexy_girl_money&quot;,10); &#125;&#125;;int main(int argc, char *argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;SingleDogNode&gt;(&quot;wang2&quot;); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 自定义通信接口创建 创建功能包 &#x3D;&#x3D;ros2 pkg create village_interfaces&#x3D;&#x3D; 创建msg文件 1234# 调用原始数据类型string content# 调用已有数据类型sensor_msgs/Image image 修改cmakelist文件 123456rosidl_generate_interfaces($&#123;PROJECT_NAME&#125; &quot;msg/Novel.msg&quot; DEPENDENCIES sensor_msgs)find_package(sensor_msgs REQUIRED)find_package(rosidl_default_generators REQUIRED) 修改xml文件 123456789&lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;&lt;depend&gt;rosidl_default_generators&lt;/depend&gt;&lt;depend&gt;geometry_msgs&lt;/depend&gt;&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt; #添加这一行&lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt;&lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt; 验证 souce ros2 interface package village_interfaces 服务介绍启动服务： 调用服务列表ros2 service list 手动调用服务ros2 service call &#x2F;add_two_ints example_interfaces&#x2F;srv&#x2F;AddTwoInts “{a: 1,b: 1}” 查看服务类型 ros2 service type &#x2F;add_two_ints 查找使用某接口的服务 ros2 service find example_interfaces&#x2F;srv&#x2F;AddTwoInts python编写srv文件配置cmakelist1234567# request string nameuint32 money---# responsebool successuint32 money 123uint32 money---string[] novels python服务端实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# import rclpy# from rclpy.node import Node# &quot;&quot;&quot; # 1. 导入库文件# 2. 初始化客户端库# 3. 新建节点# 4. spin循环节点# 5. 关闭客户端库# &quot;&quot;&quot;# def main(args=None):# # 入口函数# # 2. 初始化客户端库# rclpy.init(args=args)# # 3. 新建节点# li4_node = Node(&quot;li4&quot;)# li4_node.get_logger().info(&quot;大家好,我是作家li4&quot;)# rclpy.spin(li4_node)# rclpy.shutdownimport rclpyfrom rclpy.node import Nodefrom std_msgs.msg import String,UInt32from village_interfaces.srv import BorrowMoney&quot;&quot;&quot; 导入消息类型 声明并创建发布者 编写发布者逻辑发布数据 &quot;&quot;&quot;&quot;&quot;&quot; 1. 导入库文件 2. 初始化客户端库 3. 新建节点 4. spin循环节点 5. 关闭客户端库 &quot;&quot;&quot;&quot;&quot;&quot; 导入服务接口 创建服务器回调函数 声明并创建服务类 编写回调函数逻辑处理请求 &quot;&quot;&quot;class WriteNode(Node): def __init__(self,name): super().__init__(name) self.get_logger().info(&quot;大家好，我是作家%s&quot; % name) # 声明并创建发布者 self.pub_novel = self.create_publisher(String,&quot;sexy_girl&quot;,10) self.count = 0 self.timer_period = 5 self.timer = self.create_timer(self.timer_period,self.timer_callback) self.account = 80 self.sub_money = self.create_subscription(UInt32,&quot;sexy_girl_money&quot;,self.recv_money_callback,10) # 声明并创建服务类 self.borrow_server = self.create_service(BorrowMoney,&quot;borrow_money&quot;,self.borrow_money_callback) # 创建服务器回调函数 def borrow_money_callback(self,request,response): &quot;&quot;&quot; request 来自客户端的请求数据 response 服务端的响应数据 编写回调函数逻辑处理请求 &quot;&quot;&quot; self.get_logger().info(&quot;收到来自：%s的借钱请求，账户目前有：%d&quot; % (request.name,self.account)) if request.money &lt;= self.account*0.1: response.success = True response.money = request.money self.account = self.account - request.money self.get_logger().info(&quot;借钱成功，借出%d,目前还剩%d&quot; % (response.money,self.account)) else: response.success = False response.money = 0 self.get_logger().info(&quot;对不起，大兄弟，现在手头紧，不能借给你！&quot;) return response def timer_callback(self): msg = String() msg.data = &quot;年此外%d&quot; % self.count self.pub_novel.publish(msg) self.get_logger().info(&quot;发布了一个消息%s&quot; % msg.data) self.count +=1 def recv_money_callback(self,money): self.account += money.data self.get_logger().info(&quot;收到%d的稿费，现在账户里有%d的钱&quot; % (money.data,self.account))def main(args=None): # 入口函数 # 2. 初始化客户端库 rclpy.init(args=args) # 3. 新建节点 li4_node = WriteNode(&quot;li4&quot;) # li4_node.get_logger().info(&quot;大家好,我是作家li4&quot;) rclpy.spin(li4_node) rclpy.shutdown","categories":[],"tags":[]},{"title":"ros笔记","slug":"ros","date":"2022-07-28T15:43:08.000Z","updated":"2022-07-29T14:51:15.754Z","comments":true,"path":"2022/07/28/ros/","link":"","permalink":"http://example.com/2022/07/28/ros/","excerpt":"","text":"ros概述与环境搭建hello world实现c++123456789101112#include &quot;ros/ros.h&quot;int main(int argc, char *argv[])&#123; //执行 ros 节点初始化 ros::init(argc,argv,&quot;hello&quot;); //创建 ros 节点句柄 ros::NodeHandle n; //控制台输出 hello world ROS_INFO(&quot;hello world&quot;); return 0;&#125; 运行时先执行catkin_make,在执行roscore,然后cd 工作空间，source .&#x2F;devel&#x2F;setup.bash，rosrun 包名 C++节点 python12345678#! /usr/bin/env pythonimport rospyif __name__ == &quot;__main__&quot;: rospy.init_node(&quot;Hello&quot;) rospy.loginfo(&quot;Hello World&quot;) 1.chmod +x 自定义文件名.py2.cd 自定义空间名称3.catkin_makeroscore4.cd 工作空间5.source .&#x2F;devel&#x2F;setup.bash6.rosrun 包名 C++节点 launch文件&#x3D;&#x3D;可以一次启动多个节点&#x3D;&#x3D; 123456&lt;launch&gt; &lt;node pkg=&quot;helloworld&quot; type=&quot;demo_hello&quot; name=&quot;hello&quot; output=&quot;screen&quot; /&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot;/&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;key1&quot; /&gt;&lt;/launch&gt; 1.运行时先source2.再roslaunch 包名 文件名 命令行常用快捷键123456Alt+Up //移动到上面的终端Alt+Down //移动到下面的终端Alt+Left //移动到左边的终端Alt+Right //移动到右边的终端Ctrl+Shift+O //水平分割终端Ctrl+Shift+E //垂直分割终端 ros特有命令1.增catkin_create_pkg 自定义包名 依赖包 &#x2F;&#x2F; 创建新的ROS功能包sudo apt install xxx &#x2F;&#x2F;安装 ROS功能包2.删sudo apt purge xxx &#x2F;&#x2F; 删除某个功能包3.查rospack list &#x2F;&#x2F;列出所有功能包 rospack find 包名 &#x2F;&#x2F; 查找某个功能包是否存在，如果存在返回安装路径 roscd 包名 &#x2F;&#x2F;进入某个功能包 rosls 包名 &#x2F;&#x2F; 列出某个包下的文件 apt search xxx &#x2F;&#x2F;搜索某个功能包 4.改rosed 包名 文件名 &#x2F;&#x2F; 修改功能包文件 文件夹配置12mkdir -p 文件名catkin_make ros通信机制话题通信理论模型以发布订阅的方式实现不同节点之间数据交互的通信模式，话题通信适用于不断更新的数据传输的场景 c++实现发布方123456789101112131415161718192021222324252627282930313233include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;// /*// 发布方实现:// 1.包含头文件// 2.初始化ros节点// 3.创建节点句柄// 4.创建发布者对象// 5.编辑发布者逻辑及发布数据// */int main(int argc, char *argv[])&#123; /* code */ //初始化节点 ros::init(argc,argv,&quot;erGouZi&quot;); //创建节点句柄 ros::NodeHandle nh; //创建发布者对象 ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;fang&quot;,10); //创建被发布的消息 std_msgs::String msg; //编写循环 while(ros::ok()) &#123; msg.data = &quot;hello&quot;; pub.publish(msg); &#125; return 0;&#125; &#x3D;&#x3D;rostopic echo 话题名称 可以打印出当前发布者发布的数据&#x3D;&#x3D; rqt_graph启动计算图 代码写完需要配置txt文件 订阅方1234567891011121314151617181920212223242526#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;// /*// 订阅方实现:// 1.包含头文件// 2.初始化ros节点// 3.创建节点句柄// 4.创建订阅者对象// 5.处理订阅者逻辑及数据//spin函数void doMsg(const std_msgs::String::ConstPtr &amp;msg)&#123; //通过msg获取并操作订阅的数据 ROS_INFO(&quot;翠花订阅数据:%s&quot;,msg-&gt;data.c_str());&#125;int main(int argc, char *argv[])&#123; /* code */ ros::init(argc,argv,&quot;cuihua&quot;); ros::NodeHandle nh; ros::Subscriber sub = nh.subscribe(&quot;fang&quot;,10,doMsg); ros::spin(); return 0;&#125; 配置txt文件1 执行方式 启动roscore 使用source编译 启动发布节点 rosrun 包名 文件名 启动订阅节点 rosrun 包名 文件名 python实现发布方创建scripts文件夹 1234567891011121314151617181920212223242526272829#! /usr/bin/env pythonfrom itertools import countimport rospyfrom std_msgs.msg import String#发布的消息的类型&quot;&quot;&quot; 使用python实现消息发布 1.导包 2.初始化ros节点 3.创建发布者对象 4.编写发布逻辑并发布数据&quot;&quot;&quot;if __name__==&quot;__main__&quot;: rospy.init_node(&quot;sanDai&quot;) #传入节点名称 pub = rospy.Publisher(&quot;che&quot;,String,queue_size=10) msg=String() #制定发布频率 rate = rospy.Rate(1) #设置技计数器 count = 0 rospy.sleep(3) while not rospy.is_shutdown(): count+=1 msg.data = &quot;hello&quot; + str(count) pub.publish(msg) rospy.loginfo(&quot;发布的数据:%s&quot;,msg.data) rate.sleep() 订阅方1234567891011121314151617181920#! /usr/bin/env pythonimport rospyfrom std_msgs.msg import String&quot;&quot;&quot; 订阅实现流程 1.导包 2. 初始化ros节点 3.创建订阅者对象 4.回调函数处理数据 5.spin()&quot;&quot;&quot;def doMsg(msg): rospy.loginfo(&quot;我订阅的数据:%s&quot;, msg.data)if __name__==&quot;__main__&quot;: rospy.init_node(&quot;huaHua&quot;) sub=rospy.Subscriber(&quot;che&quot;,String,doMsg,queue_size=10) rospy.spin() 配置文件1 执行方式 添加可执行文件chmod +x *.py 启动roscore 使用source编译 启动发布节点 rosrun 包名 文件名 启动订阅节点 rosrun 包名 文件名 &#x3D;&#x3D;c++与python可实现跨代码运行&#x3D;&#x3D; 自定义msg(C++)发布方123456789101112131415161718192021222324252627282930313233343536#include &quot;ros/ros.h&quot;#include &quot;plumbing_pub_sub/Person.h&quot;/* 发布方:发布人的消息 1.包含头文件 2.初始化ros节点 3.创建ros节点句柄 4.创建发布者对象 5.编写发布逻辑发布数据 */int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ROS_INFO(&quot;消息的发布方&quot;); ros::init(argc, argv, &quot;banZhuRen&quot;); ros::NodeHandle nh; ros::Publisher pub = nh.advertise&lt;plumbing_pub_sub::Person&gt;(&quot;liaotian&quot;,10); plumbing_pub_sub::Person person; person.name = &quot;张三&quot;; person.age = 1; person.height = 1.73; ros::Rate rate(1); while (ros::ok()) &#123; //修改被发布数据 person.age += 1; //核心:数据发布 pub.publish(person); ROS_INFO(&quot;发布的消息:%s,%d,%.2f&quot;,person.name.c_str(),person.age,person.height); rate.sleep(); ros::spinOnce(); &#125; return 0;&#125; 文件配置12345678910111213141516171819202122232425262728293031ind_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation)add_message_files( FILES Person.msg)generate_messages( DEPENDENCIES std_msgs)catkin_package(# INCLUDE_DIRS include# LIBRARIES plumbing_pub_sub CATKIN_DEPENDS roscpp rospy std_msgs message_runtime# DEPENDS system_lib)add_executable(demo03_pub_person src/demo03_pub_person.cpp)add_dependencies(demo03_pub_person $&#123;PROJECT_NAME&#125;_generate_messages_cpp)target_link_libraries(demo03_pub_person $&#123;catkin_LIBRARIES&#125;) 可以使用&#x3D;&#x3D;rostopic echo +话题名称&#x3D;&#x3D;验证发布的消息 订阅方1234567891011121314151617181920212223242526272829#include &quot;ros/ros.h&quot;#include &quot;plumbing_pub_sub/Person.h&quot;/* 订阅方:订阅人的消息 1.包含头文件 2.初始化ros节点 3.创建ros节点句柄 4.创建订阅者对象 5.处理订阅数据 6.spin() */void doPerson(const plumbing_pub_sub::Person::ConstPtr&amp; person) &#123; ROS_INFO(&quot;订阅人的信息%s,%d,%.2f&quot;,person-&gt;name.c_str(),person-&gt;age,person-&gt;height);&#125;int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ROS_INFO(&quot;订阅方实现&quot;); ros::init(argc,argv,&quot;jiazhang&quot;); ros::NodeHandle nh; ros::Subscriber sub = nh.subscribe(&quot;liaotian&quot;,10,doPerson); ros::spin(); return 0;&#125; 文件配置12345678add_executable(demo04_sub_person src/demo04_sub_person.cpp)add_dependencies(demo04_sub_person $&#123;PROJECT_NAME&#125;_generate_messages_cpp)target_link_libraries(demo04_sub_person $&#123;catkin_LIBRARIES&#125;) 自定义msg(python)发布方12345678910111213141516171819202122232425262728#! /usr/bin/evn pythonimport rospyfrom plumbing_pub_sub.msg import Person&quot;&quot;&quot; 发布方： 1.导包： 2.初始化节点 3.创建发布者对象 4.组织发布者逻辑发布数据 &quot;&quot;&quot;if __name__==&quot;__main__&quot;: rospy.init_node(&quot;daMa&quot;) pub = rospy.Publisher(&quot;jiaoSheTou&quot;,Person,queue_size=10) #创建person数据 p = Person() p.name = &quot;奥特曼&quot; p.age = 8 p.height = 1.85 #创建rate对象 rate = rospy.Rate(1) #循环发布数据 while not rospy.is_shutdown(): pub.publish(p) rospy.loginfo(&quot;发布的消息：%s,%d,%.2f&quot;,p.name,p.age,p.height) rate.sleep() 可以使用&#x3D;&#x3D;rostopic echo +话题名称&#x3D;&#x3D;验证发布的消息 订阅方1234567891011121314151617181920#! /usr/bin/env/pythonimport rospyfrom plumbing_pub_sub.msg import Person&quot;&quot;&quot; 发布方： 1.导包： 2.初始化节点 3.创建订阅者对象 4.处理订阅的的数据 5.spin() &quot;&quot;&quot;def doPerson(person): rospy.loginfo(&quot;小伙子的数据：%s,%d,%.2f&quot;,person.name,person.age,person.height)if __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;daYe&quot;) sub = rospy.Subscriber(&quot;jiaoSheTou&quot;,Person,doPerson) rospy.spin() 配置文件12345678catkin_install_python(PROGRAMS scripts/demo03_pub_person_p.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;)catkin_install_python(PROGRAMS scripts/demo04_sub_person_p.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 服务通信理论模型以请求响应的方式实现不同节点之间数据交互的通信模式，服务通信更适用于对实时性有要求、具有一定逻辑处理的应用场景 c++实现服务端1234567891011121314151617181920212223242526272829303132333435#include &quot;ros/ros.h&quot;#include &quot;plumbing_server_client/AddInts.h&quot;/* 服务端实现：解析客户端提交的数据并运算在产生响应 1.包含头文件 2.初始化节点 3.创建节点句柄 4.创建一个服务对象 5.处理请求并产生响应 6.spin() */bool doNums(plumbing_server_client::AddInts::Request &amp;request, plumbing_server_client::AddInts::Response &amp;response) &#123; //1.处理请求 int num1 = request.num1; int num2 = request.num2; ROS_INFO(&quot;收到的请求数据：num1=%d,num2=%d&quot;, num1, num2); //2.组织响应 int sum = num1 + num2; response.sum = sum; ROS_INFO(&quot;求得的结果sum=%d&quot;,sum); return true;&#125;int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc,argv,&quot;heiShui&quot;);//节点名称需要保证唯一 ros::NodeHandle nh; ros::ServiceServer server = nh.advertiseService(&quot;addInts&quot;,doNums); ROS_INFO(&quot;服务器端启动&quot;); ros::spin(); return 0;&#125; &#x3D;&#x3D;rosservice call 话题名称 tab健&#x3D;&#x3D; 客户端123456789101112131415161718192021222324252627282930313233#include &quot;ros/ros.h&quot;#include &quot;plumbing_server_client/AddInts.h&quot;/* 客户端：提交二个整数，并处理响应的结果 1.包含头文件 2.初始化节点 3.创建节点句柄 4.创建一个客户端对象 5.提交请求并处理响应 */int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc,argv,&quot;daBao&quot;); ros::NodeHandle nh; ros::ServiceClient client= nh.serviceClient&lt;plumbing_server_client::AddInts&gt;(&quot;addInts&quot;); plumbing_server_client::AddInts ai; ai.request.num1 = 100; ai.request.num2 = 200; //处理响应 bool flag = client.call(ai); if(flag)&#123; ROS_INFO(&quot;响应成功&quot;); //获取结果 ROS_INFO(&quot;响应结果=%d&quot;,ai.response.sum); &#125; else&#123; ROS_INFO(&quot;处理失败&quot;); &#125; return 0;&#125; 优化123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;ros/ros.h&quot;#include &quot;plumbing_server_client/AddInts.h&quot;/* 客户端：提交二个整数，并处理响应的结果 1.包含头文件 2.初始化节点 3.创建节点句柄 4.创建一个客户端对象 5.提交请求并处理响应 //实现参数的动态提交 1. 格式：rosrun xxxx xxxx 12 34 2.节点执行时，需要获取命令中的参数，并组织进request */int main(int argc, char *argv[])&#123; //优化实现，获取命令中的参数 if(argc != 3)&#123; ROS_INFO(&quot;提交的参数个数错误&quot;); return 1; &#125; setlocale(LC_ALL, &quot;&quot;); ros::init(argc,argv,&quot;daBao&quot;); ros::NodeHandle nh; ros::ServiceClient client= nh.serviceClient&lt;plumbing_server_client::AddInts&gt;(&quot;addInts&quot;); plumbing_server_client::AddInts ai; ai.request.num1 = atoi(argv[1]); ai.request.num2 = atoi(argv[2]); //处理响应 bool flag = client.call(ai); if(flag)&#123; ROS_INFO(&quot;响应成功&quot;); //获取结果 ROS_INFO(&quot;响应结果=%d&quot;,ai.response.sum); &#125; else&#123; ROS_INFO(&quot;处理失败&quot;); &#125; return 0;&#125; &#x3D;&#x3D;如果要先启动客户端在启动服务端？&#x3D;&#x3D; ros中内置函数，这些函数可以让客户端启动后挂起，等待服务器启动 client.waitForExistence(); ros::service::waitForService(“服务话题”); python实现服务端123456789101112131415161718192021222324252627282930313233#! /usr/bin/env pythonfrom http import serverimport rospyfrom plumbing_server_client.srv import AddInts,AddIntsRequest,AddIntsResponse&quot;&quot;&quot; 服务端：解析服务端请求，产生响应 1.导包 2.初始化ros节点 3.创建服务端对象 4.处理请求(回调函数) 5.spin() &quot;&quot;&quot; #参数：封装了请求数据 #返回值：响应数据def doNum(request): #1.解析提交的两个整数 num1=request.num1 num2=request.num2 #2.求和 sum=num1+num2 #3.将结果封装响应 responce=AddIntsResponse() responce.sum=sum rospy.loginfo(&quot;服务器解析的数据num1=%d,num2=%d,响应的结果sum=%d&quot;,num1,num2,sum) return responceif __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;heiShui&quot;) server = rospy.Service(&quot;addInts&quot;, AddInts,doNum) rospy.spin() 客户端1234567891011121314151617181920#! /usr/bin/env pythonimport rospyfrom plumbing_server_client.srv import *&quot;&quot;&quot; 客户端：组织并提交请求，处理响应 1.导包 2.初始化ros节点 3.创建客户端对象 4.组织请求数据并发送请求 5.处理响应 &quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;erHei&quot;) client=rospy.ServiceProxy(&quot;addInts&quot;,AddInts) responce = client.call(12,34) rospy.loginfo(&quot;响应的数据：%d&quot;,responce.sum) 优化12345678910111213141516171819202122232425262728293031#! /usr/bin/env pythonimport rospyfrom plumbing_server_client.srv import *&quot;&quot;&quot; 客户端：组织并提交请求，处理响应 1.导包 2.初始化ros节点 3.创建客户端对象 4.组织请求数据并发送请求 5.处理响应 优化实现： 可以在执行节点时，动态传入参数 &quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;: #判断参数长度 if len(sys.argv)!=3: rospy.logerr(&quot;传入的参数个数不对&quot;) sys.exit(1) rospy.init_node(&quot;erHei&quot;) client=rospy.ServiceProxy(&quot;addInts&quot;,AddInts) #解析传入的参数 num1 = int(sys.argv[1]) num2 = int(sys.argv[2]) responce = client.call(num1,num2) rospy.loginfo(&quot;响应的数据：%d&quot;,responce.sum) &#x3D;&#x3D;如果要先启动客户端在启动服务端？&#x3D;&#x3D; ros中内置函数，这些函数可以让客户端启动后挂起，等待服务器启动 client.wait_for_service() rospy.wait_for_service(“话题名称”); 参数服务器理论模型以共享的方式实现不同节点之间数据交互的通信模式，适用于存在数据共享的一些场景 增c++实现1234567891011121314151617181920212223242526272829303132333435#include &quot;ros/ros.h&quot;/* 实现参数的新增与修改 需求：设计机器人的共享参数，类型，半径 在修改参数 实现： ros::NodeHandle setParam(&quot;键&quot;，值) ros::param set(&quot;键&quot;，值) 修改只需要继续调用setParam或set函数保证键是已经存在的，那么值会覆盖 */int main(int argc, char *argv[])&#123; //初始化ros节点 ros::init(argc, argv,&quot;set_param_c&quot;); //创建节点句柄 ros::NodeHandle nh; //参数增 //方案1： nh.setParam(&quot;type&quot;,&quot;xiaoHuang&quot;); nh.setParam(&quot;radius&quot;,0.15); //方案2： ros::param::set(&quot;type_param&quot;,&quot;xiaoBai&quot;); ros::param::set(&quot;radius_param&quot;,0.15); //参数改 //1 nh.setParam(&quot;radius&quot;,0.2); //2 ros::param::set(&quot;radius_param&quot;,0.25); return 0;&#125; python实现123456789101112131415161718#! /usr/bin/env python&quot;&quot;&quot; 参数的新增与修改 需求：在参数服务器中设置机器人属性，型号，半径 实现： rospy.set_param() &quot;&quot;&quot;import rospyif __name__ == &quot;__main__&quot;: rospy.init_node(&quot;param_set_p&quot;) rospy.set_param(&quot;type_p&quot;,&quot;xiaoHuangChe&quot;) rospy.set_param(&quot;radius_p&quot;,0.15) rospy.set_param(&quot;radius_p&quot;,0.2) 获取c++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &quot;ros/ros.h&quot;/* 演示参数查询 实现： ros::NodeHandle-------------------------------- param(键,默认值) 存在，返回对应结果，否则返回默认值 getParam(键,存储结果的变量) 存在,返回 true,且将值赋值给参数2 若果键不存在，那么返回值为 false，且不为参数2赋值 getParamCached键,存储结果的变量)--提高变量获取效率 存在,返回 true,且将值赋值给参数2 若果键不存在，那么返回值为 false，且不为参数2赋值 getParamNames(std::vector&lt;std::string&gt;) 获取所有的键,并存储在参数 vector 中 hasParam(键) 是否包含某个键，存在返回 true，否则返回 false searchParam(参数1，参数2) 搜索键，参数1是被搜索的键，参数2存储搜索结果的变量 ros::param ----- 与 NodeHandle 类似 ros::param-------------------------------- 修改只需要继续调用setParam或set函数保证键是已经存在的，那么值会覆盖 */int main(int argc, char *argv[])&#123; //设置编码 setlocale(LC_ALL, &quot;&quot;); //初始化ros节点 ros::init(argc, argv,&quot;get_param_c&quot;); //创建节点句柄 ros::NodeHandle nh; // ros::NodeHandle--------------------------------------------- //1.param double radius = nh.param(&quot;radius&quot;,0.5); ROS_INFO(&quot;radius: %.2f&quot;,radius); //2.getParam //3.getParamCached用法与2类似只是性能会提升 double radius2 = 0.0; bool result = nh.getParamCached(&quot;radius&quot;,radius2); if(result )&#123; ROS_INFO(&quot;获取的半径是：%f&quot;,radius2); &#125;else&#123; ROS_INFO(&quot;被查询的变量不存在&quot;); ROS_INFO(&quot;获取的半径是：%f&quot;,radius2); &#125; //4.getParamNames std::vector&lt;std::string&gt; names; nh.getParamNames(names); for(auto &amp;&amp;name:names)&#123; ROS_INFO(&quot;遍历到的元素：%s&quot;,name.c_str()); &#125; //5.hasParam bool flag1 = nh.hasParam(&quot;radius&quot;); bool flag2 = nh.hasParam(&quot;radiusxxx&quot;); ROS_INFO(&quot;radius存在吗?%d&quot;,flag1); ROS_INFO(&quot;radiusxxx存在吗?%d&quot;,flag2); //6.searchParam std::string key; nh.searchParam(&quot;radius&quot;,key); ROS_INFO(&quot;搜索结果%s&quot;,key.c_str()); // ros::param------------------------------------------------ double radius_param = ros::param::param(&quot;radius&quot;,100.5); // ROS_INFO(&quot;radius&quot;,radius_param); std::vector&lt;std::string&gt;names_param; ros::param::getParamNames(names_param); for (auto &amp;&amp;name : names_param) &#123; ROS_INFO(&quot;键：%s&quot;,name.c_str()); &#125; return 0;&#125; python12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &quot;ros/ros.h&quot;/* 演示参数查询 实现： ros::NodeHandle-------------------------------- param(键,默认值) 存在，返回对应结果，否则返回默认值 getParam(键,存储结果的变量) 存在,返回 true,且将值赋值给参数2 若果键不存在，那么返回值为 false，且不为参数2赋值 getParamCached键,存储结果的变量)--提高变量获取效率 存在,返回 true,且将值赋值给参数2 若果键不存在，那么返回值为 false，且不为参数2赋值 getParamNames(std::vector&lt;std::string&gt;) 获取所有的键,并存储在参数 vector 中 hasParam(键) 是否包含某个键，存在返回 true，否则返回 false searchParam(参数1，参数2) 搜索键，参数1是被搜索的键，参数2存储搜索结果的变量 ros::param ----- 与 NodeHandle 类似 ros::param-------------------------------- 修改只需要继续调用setParam或set函数保证键是已经存在的，那么值会覆盖 */int main(int argc, char *argv[])&#123; //设置编码 setlocale(LC_ALL, &quot;&quot;); //初始化ros节点 ros::init(argc, argv,&quot;get_param_c&quot;); //创建节点句柄 ros::NodeHandle nh; // ros::NodeHandle--------------------------------------------- //1.param double radius = nh.param(&quot;radius&quot;,0.5); ROS_INFO(&quot;radius: %.2f&quot;,radius); //2.getParam //3.getParamCached用法与2类似只是性能会提升 double radius2 = 0.0; bool result = nh.getParamCached(&quot;radius&quot;,radius2); if(result )&#123; ROS_INFO(&quot;获取的半径是：%f&quot;,radius2); &#125;else&#123; ROS_INFO(&quot;被查询的变量不存在&quot;); ROS_INFO(&quot;获取的半径是：%f&quot;,radius2); &#125; //4.getParamNames std::vector&lt;std::string&gt; names; nh.getParamNames(names); for(auto &amp;&amp;name:names)&#123; ROS_INFO(&quot;遍历到的元素：%s&quot;,name.c_str()); &#125; //5.hasParam bool flag1 = nh.hasParam(&quot;radius&quot;); bool flag2 = nh.hasParam(&quot;radiusxxx&quot;); ROS_INFO(&quot;radius存在吗?%d&quot;,flag1); ROS_INFO(&quot;radiusxxx存在吗?%d&quot;,flag2); //6.searchParam std::string key; nh.searchParam(&quot;radius&quot;,key); ROS_INFO(&quot;搜索结果%s&quot;,key.c_str()); // ros::param------------------------------------------------ double radius_param = ros::param::param(&quot;radius&quot;,100.5); // ROS_INFO(&quot;radius&quot;,radius_param); std::vector&lt;std::string&gt;names_param; ros::param::getParamNames(names_param); for (auto &amp;&amp;name : names_param) &#123; ROS_INFO(&quot;键：%s&quot;,name.c_str()); &#125; return 0;&#125; 删除c++123456789101112131415161718192021222324252627282930313233343536373839#include &quot;ros/ros.h&quot;/* 参数的删除： 实现： ros::NodeHandle delParam() ros::param del() */int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc,argv,&quot;param_del_c&quot;); ros::NodeHandle nh; //1. bool flag1 = nh.deleteParam(&quot;radius&quot;); if (flag1) &#123; ROS_INFO(&quot;删除成功了&quot;); &#125;else &#123; ROS_INFO(&quot;删除失败了&quot;); &#125; //ros::param bool flag2 = ros::param::del(&quot;radius_param&quot;); if (flag2) &#123; ROS_INFO(&quot;删除成功了&quot;); &#125;else &#123; ROS_INFO(&quot;删除失败了&quot;); &#125; return 0;&#125; python12345678910#! /usr/bin/env pythonimport rospyif __name__ == &quot;__main__&quot;: rospy.init_node(&quot;del_param_p&quot;) try: rospy.delete_param(&quot;radius_p&quot;) except Exception as e: rospy.loginfo(&quot;被删除的参数不存在&quot;) 常用命令ros常用命令 rosnode rosnode ping 测试到节点的连接状态 rosnode list 列出活动节点 rosnode info 打印节点信息 rosnode machine 列出指定设备上节点 rosnode kill 杀死某个节点 rosnode cleanup 清除不可连接的节点 rostopic rostopic bw 显示主题使用的带宽 rostopic delay 显示带有 header 的主题延迟 rostopic echo 打印消息到屏幕 rostopic find 根据类型查找主题 rostopic hz 显示主题的发布频率 rostopic info 显示主题相关信息 rostopic list 显示所有活动状态下的主题 rostopic pub 将数据发布到主题 rostopic type 打印主题类型 rosmsg rosmsg show 显示消息描述 rosmsg info 显示消息信息 rosmsg list 列出所有消息 rosmsg md5 显示 md5 加密后的消息 rosmsg package 显示某个功能包下的所有消息 rosmsg packages 列出包含消息的功能包 rosservice rosservice args 打印服务参数 rosservice call 使用提供的参数调用服务 rosservice find 按照服务类型查找服务 rosservice info 打印有关服务的信息 rosservice list 列出所有活动的服务 rosservice type 打印服务类型 rosservice uri 打印服务的 ROSRPC uri rossrv rossrv show 显示服务消息详情 rossrv info 显示服务消息相关信息 rossrv list 列出所有服务信息 rossrv md5 显示 md5 加密后的服务消息 rossrv package 显示某个包下所有服务消息 rossrv packages 显示包含服务消息的所有包 rosparam rosparam set 设置参数 rosparam get 获取参数 rosparam load 从外部文件加载参数 rosparam dump 将参数写出到外部文件 rosparam delete 删除参数 rosparam list 列出所有参数 通信机制实操实操1用途实现乌龟运动控制 1234rostopic listrqt_graphrostopic info /turtle1/cmd_vel (rostopic type /turtle1/cmd_vel)rosmsg show geometry_msgs/Twist c++实现123456789101112131415161718192021222324252627282930313233343536373839#include &quot;ros/ros.h&quot;#include &quot;geometry_msgs/Twist.h&quot;/* 需求：发布速度消息 话题：/turtle1/cmd_vel 消息：geometry_msgs/Twist 1.包含头文件 2.初始化ros节点 3.创建节点句柄 4.创建发布对象 5.发布逻辑实现 6.spiOnce() */int main(int argc, char *argv[])&#123; ros::init(argc,argv,&quot;my_control&quot;); ros::NodeHandle nh; ros::Publisher pub = nh.advertise&lt;geometry_msgs::Twist&gt;(&quot;turtle1/cmd_vel&quot;,10); ros::Rate rate(10);//设置发布频率 //组织消息 geometry_msgs::Twist twist; twist.linear.x = 1.0; twist.linear.y = 0.0; twist.linear.z = 0.0; twist.angular.z = 1.0; twist.angular.y = 0.0; twist.angular.x = 0.0; while (ros::ok()) &#123; pub.publish(twist); //休眠 rate.sleep(); ros::spinOnce(); &#125; return 0;&#125; python实现1234567891011121314151617181920212223242526272829303132#! /usr/bin/env pythonimport rospyfrom geometry_msgs.msg import Twist&quot;&quot;&quot; 发布方：发布速度消息 话题：/turtle1/cmd_vel 消息:geometry_msgs/Twist 1.导包 2.初始化ros节点 3.创建发布者对象 4.组织数据并发布数据 &quot;&quot;&quot;if __name__ == &quot;__main__&quot;: rospy.init_node(&quot;my_control_p&quot;) pub = rospy.Publisher(&quot;turtle1/cmd_vel&quot;,Twist,queue_size=10) #设置发布频率 rate = rospy.Rate(10) twist = Twist() twist.linear.x=0.5 twist.linear.y=0.0 twist.linear.z=0.0 twist.angular.x=0.0 twist.angular.y=0.0 twist.angular.z=0.5 while not rospy.is_shutdown(): pub.publish(twist) rate.sleep() 实操2用途打印乌龟当前位姿 c++实现12345678910111213141516171819202122232425#include &quot;ros/ros.h&quot;#include &quot;turtlesim/Pose.h&quot;/* 需求：订阅乌龟的位姿信息，并输出到控制台 1.包含头文件 2.初始化ros节点 3。创建节点句柄 4.创建订阅对象 5.处理订阅数据(回调函数) 6.spin() */void doPose(const turtlesim::Pose::ConstPtr &amp;pose)&#123; ROS_INFO(&quot;乌龟的位姿信息：坐标(%.2f,%.2f),朝向(%.2f),线速度：%.2f,角速度：%.2f&quot;, pose-&gt;x,pose-&gt;y,pose-&gt;theta,pose-&gt;linear_velocity,pose-&gt;angular_velocity);&#125;int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc,argv,&quot;sub_pose&quot;); ros::NodeHandle nh; ros::Subscriber sub = nh.subscribe(&quot;/turtle1/pose&quot;,100,doPose); ros::spin(); return 0;&#125; python实现123456789101112131415161718192021#! /usr/bin/env pythonimport rospyfrom turtlesim.msg import Pose&quot;&quot;&quot; 需求：订阅并输出乌龟的位姿信息 1.导包 2.初始化ros节点 3.创建订阅对象 4.使用回调函数处理订阅到的消息 5.spin() &quot;&quot;&quot;def doPose(pose): rospy.loginfo(&quot;P-&gt;乌龟位姿信息：坐标(%.2f,%.2f),朝向(%.2f),线速度：%.2f,角速度：%.2f&quot;, pose.x,pose.y,pose.theta,pose.linear_velocity,pose.angular_velocity)if __name__ == &quot;__main__&quot;: rospy.init_node(&quot;sub_pose_p&quot;) sub = rospy.Subscriber(&quot;/turtle1/pose&quot;,Pose,doPose,queue_size=100) rospy.spin() 实操3用途生成多个乌龟 c++实现12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;ros/ros.h&quot;#include &quot;turtlesim/Spawn.h&quot;/* 需求：向服务端发送请求，生成一只新乌龟 话题：/spawn 消息：turtlesin/Spawn 1.包含头文件 2.初始化ros节点 3.创建节点句柄 4.创建客户端对象 5.组织数据并发送 6.处理响应 */int main(int argc, char *argv[])&#123; setlocale(LC_ALL,&quot;&quot;); ros::init(argc,argv,&quot;service_call&quot;); ros::NodeHandle nh; ros::ServiceClient client = nh.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;); turtlesim::Spawn spawn; //组织请求数据 spawn.request.x = 1.0; spawn.request.y = 4.0; spawn.request.theta = 1.57; spawn.request.name = &quot;turtle2&quot;; //发送请求 //判断服务器状态 // ros::service::waitForService(&quot;/spawn&quot;); client.waitForExistence(); bool flag = client.call(spawn);//flag是用来接收响应状态的，响应结果也会被设置进spawn对象 if (flag)&#123; ROS_INFO(&quot;乌龟生成成功，新乌龟叫:%s&quot;,spawn.response.name.c_str()); &#125; else&#123; ROS_INFO(&quot;请求失败&quot;); &#125; return 0;&#125; python实现1234567891011121314151617181920212223242526272829303132#! /usr/bin/env pythonfrom http import clientimport refrom urllib import responseimport rospyfrom turtlesim.srv import Spawn,SpawnRequest,SpawnResponse&quot;&quot;&quot; 需求：向参数服务器发送请求生成一只乌龟 话题：/spawn 消息:turtlesim/Spawn 1.导包 2.初始化ros节点 3.创建服务的客户端对象 4.组织数据并发送请求 5.处理响应结果 &quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;service_call_p&quot;) client = rospy.ServiceProxy(&quot;/spawn&quot;,Spawn) request = SpawnRequest() request.x = 4.5 request.y = 2.0 request.theta = -3 request.name = &quot;turtle3&quot; client.wait_for_service() try: client.call(request) rospy.loginfo(&quot;生成乌龟的名字叫%s&quot;,response.name) except Exception as e: rospy.logerr(&quot;请求处理失败&quot;) 实操4用途修改背景颜色 c++实现1234567891011121314151617181920212223242526272829#include &quot;ros/ros.h&quot;/* 需求：修改参数服务器中turtlesim背景色相关的参数 1.初始化ros节点 2.不一定需要创建节点句柄(和后续API有关) 3.修改参数 */int main(int argc, char *argv[])&#123; ros::init(argc, argv,&quot;change_bgColor&quot;); // ros::NodeHandle nh(&quot;turtlesim&quot;); // nh.setParam(&quot;background_r&quot;,255); // nh.setParam(&quot;background_g&quot;,255); // nh.setParam(&quot;background_b&quot;,255); ros::NodeHandle nh; nh.setParam(&quot;/turtlesim/background_r&quot;,255); nh.setParam(&quot;/turtlesim/background_g&quot;,255); nh.setParam(&quot;/turtlesim/background_b&quot;,255); //如果调用ros::param 不需要创建节点句柄 // ros::param::set(&quot;/turtlesim/background_r&quot;,0); // ros::param::set(&quot;/turtlesim/background_g&quot;,0); // ros::param::set(&quot;/turtlesim/background_b&quot;,0); return 0;&#125; python实现1234567891011121314#! /usr/bin/env pythonimport rospy&quot;&quot;&quot; 需求:修改乌龟GUI背景色 1.初始化ros节点 2.设置参数 &quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;change_bgColor_p&quot;) rospy.set_param(&quot;/turtlesim/background_r&quot;,100) rospy.set_param(&quot;/turtlesim/background_g&quot;,50) rospy.set_param(&quot;/turtlesim/background_b&quot;,200) ros通信机制进阶官方api文档 常用api初始化c++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &lt;sstream&gt;// /*// 发布方实现:// 1.包含头文件// 2.初始化ros节点// 3.创建节点句柄// 4.创建发布者对象// 5.编辑发布者逻辑及发布数据// */int main(int argc, char *argv[])&#123; setlocale(LC_ALL,&quot;&quot;); //初始化节点 /* 作用：ros初始化函数 参数： 1.argc ---封装实参个数（n+1） 2.argv ---封装参数的数组 3.name --- 为节点命名（保证唯一性） 4.options ---- 节点启动对象 返回值：void 使用： 1.argc与argv的使用 如果按照ros中的特定格式传入实参，那么ros可以加以使用，比如用来设置全局参数，给节点重命名 2.options的使用 节点名称需要保证唯一，会导致一个问题：同一个节点不能重复启动 结果：当有重名的节点启动时那么之前的节点就会被关闭 需求：特定场景下，需要一个节点多次启动且能正常运行？？？ 解决：设置启动项：ros::init_options::AnonymousName 当创建ros节点时，会在用户自定义的节点名称后缀随机数，从而避免重名问题 */ ros::init(argc,argv,&quot;erGouZi&quot;,ros::init_options::AnonymousName); //创建节点句柄 ros::NodeHandle nh; ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;fang&quot;,true); //创建被发布的消息 std_msgs::String msg; //编写循环 //要求以10hz的频率发布数据,文本后添加编号 //发布频率 ros::Rate rate(10); //设置编号 int count=0; //为了防止前几个数据丢失一般加入休眠 ros::Duration(3).sleep(); while(ros::ok()) &#123; //如果计数器大于50,那么关闭节点 if(count&gt;=50)&#123; ros::shutdown(); &#125; count++; // msg.data = &quot;hello&quot;; // 实现字符串拼接 std::stringstream ss; ss &lt;&lt; &quot;hello ---&gt;&quot;&lt;&lt;count; msg.data=ss.str(); // if(count &lt;=10)&#123; // pub.publish(msg); // //添加日志 // ROS_INFO(&quot;发布的数据是%s&quot;,ss.str().c_str()); // &#125; rate.sleep(); ros::spinOnce();//处理回调函数 ROS_INFO(&quot;一轮回调执行完毕&quot;); &#125; return 0;&#125; python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#! /usr/bin/env pythonfrom itertools import countimport rospyfrom std_msgs.msg import String#发布的消息的类型&quot;&quot;&quot; 使用python实现消息发布 1.导包 2.初始化ros节点 3.创建发布者对象 4.编写发布逻辑并发布数据&quot;&quot;&quot;if __name__==&quot;__main__&quot;: &quot;&quot;&quot; 作用:ros初始化 参数: name---设置节点名称 argv=None ---- 封装节点调用时传递的参数 anonymous=False ----可以为节点名称生成随机后缀,可以解决重名问题 使用: 1.argv使用 可以按照ros中指定的语法格式传参,ros可以解析并加以使用 2.anonymous的使用 &quot;&quot;&quot; rospy.init_node(&quot;sanDai&quot;,anonymous=True) #传入节点名称 pub = rospy.Publisher(&quot;che&quot;,String,queue_size=10,latch=True) msg=String() #制定发布频率 rate = rospy.Rate(1) #设置技计数器 count = 0 rospy.sleep(3) while not rospy.is_shutdown(): count+=1 if count&lt;=10: msg.data = &quot;hello&quot; + str(count) pub.publish(msg) rospy.loginfo(&quot;发布的数据:%s&quot;,msg.data) else: #关闭节点 rospy.signal_shutdown(&quot;关闭节点&quot;) rate.sleep() 话题与服务对象c++发布者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &lt;sstream&gt;// /*// 发布方实现:// 1.包含头文件// 2.初始化ros节点// 3.创建节点句柄// 4.创建发布者对象// 5.编辑发布者逻辑及发布数据// */int main(int argc, char *argv[])&#123; setlocale(LC_ALL,&quot;&quot;); ros::init(argc,argv,&quot;erGouZi&quot;,ros::init_options::AnonymousName); //创建节点句柄 ros::NodeHandle nh; //创建发布者对象 /* 作用：创建发布者对象 模板：被发布的消息的类型 参数： 1. 话题名称 2.队列长度 3.latch(可选) 如果是true，会保存发布方的最后一条消息，并且新的订阅对象连接到发布方时，发布方会将这条消息发送给订阅者 使用： latch 设置为true的作用？ 以静态地图发布为例，方案一：可以使用固定频率发送地图数据，但是效率低 方案二：可以将地图发布对象的latch设置为true，并且发布方只发送一次数据时，每当订阅者连接时，将地图数据发送给订阅者（至发送一次），提高了数据发送效率 */ ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;fang&quot;,true); //创建被发布的消息 std_msgs::String msg; //编写循环 //要求以10hz的频率发布数据,文本后添加编号 //发布频率 ros::Rate rate(10); //设置编号 int count=0; //为了防止前几个数据丢失一般加入休眠 ros::Duration(3).sleep(); while(ros::ok()) &#123; //如果计数器大于50,那么关闭节点 if(count&gt;=50)&#123; ros::shutdown(); &#125; count++; // msg.data = &quot;hello&quot;; // 实现字符串拼接 std::stringstream ss; ss &lt;&lt; &quot;hello ---&gt;&quot;&lt;&lt;count; msg.data=ss.str(); // if(count &lt;=10)&#123; // pub.publish(msg); // //添加日志 // ROS_INFO(&quot;发布的数据是%s&quot;,ss.str().c_str()); // &#125; rate.sleep(); ros::spinOnce();//处理回调函数 ROS_INFO(&quot;一轮回调执行完毕&quot;); &#125; return 0;&#125; 订阅方1234567891011121314151617181920212223242526#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;// /*// 订阅方实现:// 1.包含头文件// 2.初始化ros节点// 3.创建节点句柄// 4.创建订阅者对象// 5.处理订阅者逻辑及数据//spin函数void doMsg(const std_msgs::String::ConstPtr &amp;msg)&#123; //通过msg获取并操作订阅的数据 ROS_INFO(&quot;翠花订阅数据:%s&quot;,msg-&gt;data.c_str());&#125;int main(int argc, char *argv[])&#123; /* code */ ros::init(argc,argv,&quot;cuihua&quot;); ros::NodeHandle nh; ros::Subscriber sub = nh.subscribe(&quot;fang&quot;,10,doMsg); ros::spin(); return 0;&#125; python发布方123456789101112131415161718192021222324252627282930313233343536373839404142434445#! /usr/bin/env pythonfrom itertools import countimport rospyfrom std_msgs.msg import String#发布的消息的类型&quot;&quot;&quot; 使用python实现消息发布 1.导包 2.初始化ros节点 3.创建发布者对象 4.编写发布逻辑并发布数据&quot;&quot;&quot;if __name__==&quot;__main__&quot;: rospy.init_node(&quot;sanDai&quot;,anonymous=True) #传入节点名称 pub = rospy.Publisher(&quot;che&quot;,String,queue_size=10,latch=True) # //创建发布者对象 # /* # 作用：创建发布者对象 # bool值 默认false # 参数： # latch(可选) 如果是true，会保存发布方的最后一条消息，并且新的订阅对象连接到发布方时，发布方会将这条消息发送给订阅者 # 使用： # latch 设置为true的作用？ # 以静态地图发布为例，方案一：可以使用固定频率发送地图数据，但是效率低 # 方案二：可以将地图发布对象的latch设置为true，并且发布方只发送一次数据时，每当订阅者连接时，将地图数据发送给订阅者（至发送一次），提高了数据发送效率 # */ msg=String() #制定发布频率 rate = rospy.Rate(1) #设置技计数器 count = 0 rospy.sleep(3) while not rospy.is_shutdown(): count+=1 if count&lt;=10: msg.data = &quot;hello&quot; + str(count) pub.publish(msg) rospy.loginfo(&quot;发布的数据:%s&quot;,msg.data) else: #关闭节点 rospy.signal_shutdown(&quot;关闭节点&quot;) rate.sleep() 回旋函数和时间c++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;ros/ros.h&quot;/* 需求1：演示时间相关操作(获取当前时刻+设置指定时刻 实现： 1.准备(头文件，节点初始化，NodeHandler创建...) 2.获取当前时刻 3.设置制定时刻 需求2：在程序执行中停顿5s 实现： 1.创建持续时间对象 2.休眠 需求3:已知程序运行的时刻和程序运行的时间,求运行结束时刻 实现: 1.获取开始执行的时刻 2.模拟运行时间(n秒) 3.计算结束时刻 = 开始+持续时间 时刻之间之可以相减不可以相加 需求4:要求每隔1秒,在控制台输出一段文本 实现: 1.使用ros::Rate() 2.定时器 *///回调函数void cb(const ros::TimerEvent&amp; event)&#123; ROS_INFO(&quot;--------&quot;);&#125;int main(int argc, char *argv[])&#123; // 1.准备(头文件，节点初始化，NodeHandler创建...) setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv, &quot;hello_time&quot;); ros::NodeHandle nh;//必须，否则会导致时间初始化失败(在NodeHandler会初始化时间操作) // 2.获取当前时刻 //参考系：1970.01.01。00.00.00 ros::Time right_now = ros::Time::now(); ROS_INFO(&quot;当前时刻为：%.2f&quot;,right_now.toSec()); ROS_INFO(&quot;当前时刻为：%d&quot;,right_now.sec); // 3.设置制定时刻 ros::Time t1(20,312345678); ROS_INFO(&quot;t1=%.2f&quot;,t1.toSec()); //----------------------------持续时间------------------------------------ ROS_INFO(&quot;开始休眠&quot;); ros::Duration du(4.5); du.sleep(); ros::Time end= ros::Time::now(); ROS_INFO(&quot;休眠结束&quot;); //----------------------------时间运算----------------------------------- // 1.获取开始执行的时刻 ros::Time begin = ros::Time::now(); // 2.模拟运行时间(n秒) ros::Duration du1(5); // 3.计算结束时刻 = 开始+持续时间 ros::Time stop = begin + du1; //时刻与时刻的运算 // ros::Time sum = begin + stop;//不可以相加 ros::Duration du2 = begin -stop; //持续时间与持续时间的运算 ros::Duration du3 = du1+du2; ros::Duration du4 = du1-du2; //----------------------------定时器----------------------------------- /* ros::Timer createTimer(ros::Duration period, //时间间隔1s const ros::TimerCallback &amp;callback, //回调函数 bool oneshot = false, //是否是一次性的 bool autostart = true) const //自动启动,当设置为false时,需要手动调用timer.start() 定时器启动后:ros::spin() */ ros::Timer timer = nh.createTimer(ros::Duration(1),cb); ros::spin();//需要回旋 return 0;&#125; python12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#! /usr/bin/env pythonimport rospy&quot;&quot;&quot; 需求1:演示时间相关操作(获取当前时刻+设置指定时刻） 需求2:在程序执行中停顿5s 需求3:已知程序运行的时刻和程序运行的时间,求运行结束时刻 需求4:要求每隔1秒,在控制台输出一段文本 &quot;&quot;&quot;def doMsg(event): rospy.loginfo(&quot;--------------------------------&quot;) rospy.loginfo(&quot;调用回调函数的时刻：%.2f&quot;,event.current_real.to_sec())if __name__ == &#x27;__main__&#x27;: # 需求1:演示时间相关操作(获取当前时刻+设置指定时刻） rospy.init_node(&quot;hello_time_p&quot;) # 获取时刻 right_now = rospy.Time.now() #将当前时刻获取并封装成对象 rospy.loginfo(&quot;当前时刻：%.2f&quot;,right_now.to_sec()) rospy.loginfo(&quot;当前时刻：%d&quot;,right_now.secs) # 设置指定 time1 = rospy.Time(100)#将时间(1970年1月1日 00.00.00 逝去100秒)封装成timme对象 time2 = rospy.Time(100,312345678)#将时间(1970年1月1日 00.00.00 逝去100.312345678秒)封装成timme对象 rospy.loginfo(&quot;指定时刻1:%.2f&quot;,time1.to_sec()) rospy.loginfo(&quot;指定时刻2:%.2f&quot;,time2.to_sec()) #从某个时间值获取时间对象 time3 = rospy.Time.from_sec(210.12) rospy.loginfo(&quot;指定时刻3:%.2f&quot;,time3.to_sec()) # 需求2:在程序执行中停顿5s rospy.loginfo(&quot;休眠前------------------------&quot;) # 1.封装一个时间对象（5秒） du = rospy.Duration(5) # 2.在将持续时间休眠 rospy.sleep(du) rospy.loginfo(&quot;休眠后------------------------&quot;) # 需求3:已知程序运行的时刻和程序运行的时间,求运行结束时刻 # 1.获取一个时刻 t1 t1 = rospy.Time.now() # 2.设置持续时间 du1 du1 = rospy.Duration(5) # 3.结束时刻 t2 = t1 + du1 t2 = t1 + du1 rospy.loginfo(&quot;开始时刻：%.2f&quot;,t1.to_sec()) rospy.loginfo(&quot;结束时刻：%.2f&quot;,t2.to_sec()) du2 = du +du1 rospy.loginfo(&quot;持续时间相加:%.2f&quot;,du2.to_sec()) # t2 = right_now + t1 会抛异常 # 需求4：设置定时器，每隔一段时间执行某种操作 timer = rospy.Timer(rospy.Duration(2),doMsg,True)#创建一个定时器对象,当为TRUE时只执行一次回调函数 rospy.spin() #重要 其他函数c++123456789101112131415161718192021#include &quot;ros/ros.h&quot;/* ros中日志: 演示不同级别日志的基本使用 */int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv, &quot;hello_log&quot;); ros::NodeHandle nh; //日志输出 ROS_DEBUG(&quot;调试信息&quot;);//不会打印在控制台 ROS_INFO(&quot;一般信息&quot;); ROS_WARN(&quot;警告信息&quot;); ROS_ERROR(&quot;错误信息&quot;); ROS_FATAL(&quot;严重错误&quot;); return 0;&#125; python12345678910111213#! /usr/bin/env pythonimport rospyif __name__ == &#x27;__main__&#x27;: #演示日志函数 rospy.init_node(&quot;hello_log_p&quot;) rospy.logdebug(&quot;DEBUG&quot;) rospy.loginfo(&quot;info消息&quot;) rospy.logwarn(&quot;WARNING&quot;) rospy.logerr(&quot;ERROR&quot;) rospy.logfatal(&quot;fatal&quot;) ros中头文件和源文件的调用1234567891011121314151617#ifndef _HELLO_H#define _HELLO_H/* 声明 namespace |-- class |-- run */namespace hello_ns&#123;class MyHello&#123; public: void run();&#125;;&#125;#endif 头文件调用1234567891011121314151617#include &quot;ros/ros.h&quot;#include &quot;plumbing_head/hello.h&quot;namespace hello_ns&#123; void MyHello::run()&#123; ROS_INFO(&quot;run函数执行&quot;);&#125;&#125;int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv, &quot;hello_head&quot;); hello_ns::MyHello myHello; myHello.run(); return 0;&#125; 源文件的调用123456789#include &quot;plumbing_head_src/hello.h&quot;#include &quot;ros/ros.h&quot;namespace hello_ns&#123; void MyHello::run() &#123; ROS_INFO(&quot;源文件中的run函数&quot;); &#125;&#125; 123456789101112#include &quot;ros/ros.h&quot;#include &quot;plumbing_head_src/hello.h&quot;int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv, &quot;hello_head_src&quot;); hello_ns::MyHello myHello; myHello.run(); return 0;&#125; python模块导入1234567891011121314151617181920212223242526272829303132333435363738394041424344#! /usr/bin/env pythonimport osimport sysfrom itertools import countimport rospyfrom std_msgs.msg import String#发布的消息的类型import tools# 设置临时环境变量# 路径写死影响代码的可移植性# sys.path.insert(0,&quot;/home/zhuwencheng/demo03_ws/src/plumbing_pub_sub/scripts&quot;)#优化，可以动态获取路径path = os.path.abspath(&quot;.&quot;)sys.path.insert(0,path+&quot;/src/plumbing_pub_sub/scripts&quot;)&quot;&quot;&quot; 使用python实现消息发布 1.导包 2.初始化ros节点 3.创建发布者对象 4.编写发布逻辑并发布数据&quot;&quot;&quot;if __name__==&quot;__main__&quot;: rospy.init_node(&quot;sanDai&quot;) #传入节点名称 path = os.path.abspath(&quot;.&quot;) &quot;&quot;&quot; 原因：rosrun执行是，参考路径是工作空间的路径，在工作空间下，无法查找依赖的模块 解决：可以声明python的环境变量，当依赖某个模块时，先去指定的模块中查找依赖 &quot;&quot;&quot; rospy.loginfo(&quot;执行时参考的路径：%s&quot;,path) rospy.loginfo(&quot;tools:%d&quot;,tools.num) pub = rospy.Publisher(&quot;che&quot;,String,queue_size=10) msg=String() #制定发布频率 rate = rospy.Rate(1) #设置技计数器 count = 0 rospy.sleep(3) while not rospy.is_shutdown(): count+=1 msg.data = &quot;hello&quot; + str(count) pub.publish(msg) rospy.loginfo(&quot;发布的数据:%s&quot;,msg.data) rate.sleep() tools123#! /usr/bin/env pythonnum = 100 ros运行管理ros元功能包12345cmake_minimum_required(VERSION 3.0.2)project(plumbing_my)find_package(catkin REQUIRED)catkin_metapackage() 1234&lt;export&gt; &lt;!-- Other tools can request additional information be placed here --&gt; &lt;metapackage /&gt; &lt;/export&gt; launchlaunch,node,remap,param,rosparam标签12345678910111213141516171819202122232425&lt;!-- deprecated=&quot;此文件已经过时，不建议使用&quot; --&gt;&lt;launch &gt; &lt;!-- 启动的节点 --&gt; &lt;!-- respawn=&quot;true&quot;节点启动后自动重启 --&gt; &lt;!-- required=&quot;true&quot;节点退出后关闭整个系统 --&gt; &lt;!-- ns=&quot;hello&quot;设置节点的命名空间 --&gt; &lt;!-- param使用：向参数服务器设置参数 --&gt; &lt;!-- 格式一：launch下，node外 --&gt; &lt;param name=&quot;param_A&quot; type=&quot;int&quot; value=&quot;100&quot; /&gt; &lt;!-- rosparam的使用：操作参数服务器数据 --&gt; &lt;!-- 格式一：launch下，node外 --&gt; &lt;!-- 加载参数 --&gt; &lt;rosparam command=&quot;load&quot; file=&quot;$(find launch01_basic)/launch/params.yaml&quot; /&gt; &lt;!-- 导出参数 --&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;my_turtle&quot; output=&quot;screen&quot; &gt; &lt;remap from=&quot;/turtle1/cmd_vel&quot; to=&quot;/cmd/vel&quot; /&gt; &lt;!-- 格式2：node下 --&gt; &lt;param name=&quot;param_B&quot; type=&quot;double&quot; value=&quot;3.14&quot; /&gt; &lt;!-- 格式2：node下 --&gt; &lt;rosparam command=&quot;load&quot; file=&quot;$(find launch01_basic)/launch/params.yaml&quot; /&gt; &lt;/node&gt; &lt;!-- 键盘控制 --&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;my_key&quot; output=&quot;screen&quot; /&gt;&lt;/launch&gt; group12345678910111213141516&lt;launch&gt; &lt;!-- 启动两对乌龟gui与键盘控制节点 --&gt; &lt;group ns=&quot;first&quot;&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;my_turtle&quot; output=&quot;screen&quot; /&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;my_key&quot; output=&quot;screen&quot; /&gt; &lt;/group&gt; &lt;group ns=&quot;second&quot;&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;my_turtle&quot; output=&quot;screen&quot; /&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;my_key&quot; output=&quot;screen&quot; /&gt; &lt;/group&gt; &lt;/launch&gt; include12345678&lt;!-- 需要复用start_turtle.launch --&gt;&lt;launch&gt; &lt;!-- 包含 --&gt; &lt;include file=&quot;$(find launch01_basic)/launch/start_turtle.launch&quot; /&gt; &lt;!-- 其他节点 --&gt; &lt;/launch&gt; arg1234567891011&lt;launch&gt; &lt;!-- 需求：演示arg的使用，需要设置多个参数，这些参数使用的是同一个值(小车的长度)，怎么设置？ --&gt; &lt;!-- &lt;param name=&quot;A&quot; value=&quot;0.5&quot; /&gt; &lt;param name=&quot;B&quot; value=&quot;0.5&quot; /&gt; &lt;param name=&quot;C&quot; value=&quot;0.5&quot; /&gt; --&gt; &lt;arg name=&quot;car_length&quot; default=&quot;0.55&quot; /&gt; &lt;param name=&quot;A&quot; value=&quot;$(arg car_length)&quot; /&gt; &lt;param name=&quot;B&quot; value=&quot;$(arg car_length)&quot; /&gt; &lt;param name=&quot;C&quot; value=&quot;$(arg car_length)&quot; /&gt; &lt;/launch&gt; 工作空间覆盖当功能包重名时，先配置的，会优先执行 节点名称rosrun实现123rosrun turtlesim turtlesim_node __ns:=/xxxrosrun turtlesim turtlesim_node __name:= xxx launch实现12345678910111213&lt;!-- 需要启动多个乌龟gui节点 --&gt;&lt;launch&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;turtlesim&quot; /&gt; &lt;!-- 1.名称重映射 --&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot; /&gt; &lt;!-- 2.命名空间 --&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;turtlesim&quot; ns=&quot;ergouzi&quot; /&gt; &lt;!-- 3.命名空间+映射名称 --&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t2&quot; ns=&quot;maolvzi&quot; /&gt;&lt;/launch&gt; 编码实现c++ros::init(argc,argv,””,ros::init_options::); pythonrospy.init_node(“lisi”,anonymous&#x3D;True) 话题名称rosrunrosrun teleop_twist_keyboard teleop_twist_keyboard.py &#x2F;cmd_vel:&#x3D;&#x2F;turtle1&#x2F;cmd_vel launch12345678910&lt;!-- 键盘控制乌龟运动 --&gt;&lt;launch&gt; &lt;!-- 将乌龟的话题设置为与键盘控制一至 --&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot;&gt; &lt;remap from=&quot;/turtle1/cmd_vel&quot; to=&quot;/cmd_vel&quot; /&gt; &lt;/node&gt; &lt;node pkg=&quot;teleop_twist_keyboard&quot; type=&quot;teleop_twist_keyboard.py&quot; name=&quot;key&quot; /&gt; &lt;!-- 将键盘控制设置乌龟的话题为与一至 --&gt;&lt;/launch&gt; 编码c++1234567891011121314151617181920212223242526#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;int main(int argc, char *argv[])&#123; ros::init(argc, argv, &quot;hello&quot;); ros::NodeHandle nh; //核心：设置不同类型的话题 //1.全局 ---话题名称需要以斜杠开头(也可以设置自己的命名空间)，这种情况下和节点(命名空间以及名称）没有关系 // ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;/chatter&quot;,1000); // ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;/yyy/chatter&quot;,1000); //2.相对----非/开头 // ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;,1000); // ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;yyy/chatter&quot;,1000); //3.私有 ---需要创建特定NodeHandle ros::NodeHandle nh(&quot;~&quot;); // ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;,1000); // ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;yyy/chatter&quot;,1000); ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;/yyy/chatter&quot;,1000);//如果私有的NH创建的话题以/开头，此时为全局话题 while(ros::ok())&#123; &#125; return 0;&#125; python1234567891011121314151617181920#! /usr/bin/env pythonimport rospyfrom std_msgs.msg import Stringif __name__ == &quot;__main__&quot;: rospy.init_node(&quot;hello&quot;)# 1.全局# pub = rospy.Publisher(&quot;/chatter&quot;,String,queue_size=10)# pub = rospy.Publisher(&quot;/yyy/chatter&quot;,String,queue_size=10)# # 2.相对# pub = rospy.Publisher(&quot;chatter&quot;,String,queue_size=10)# pub = rospy.Publisher(&quot;yy/chatter&quot;,String,queue_size=10)# 3.私有 pub = rospy.Publisher(&quot;~chatter&quot;,String,queue_size=10) # pub = rospy.Publisher(&quot;~yyy/chatter&quot;,String,queue_size=10) while not rospy.is_shutdown: pass 参数名称launch123456789&lt;!-- 设置参数 --&gt;&lt;launch&gt; &lt;!-- 格式一：全局 --&gt; &lt;param name=&quot;radius&quot; value=&quot;0.2&quot; /&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot; ns=&quot;xxx&quot;&gt; &lt;!-- 私有 --&gt; &lt;param name=&quot;radius&quot; value=&quot;0.08&quot; /&gt; &lt;/node&gt;&lt;/launch&gt; 编码c++123456789101112131415161718192021222324252627282930#include &quot;ros/ros.h&quot;int main(int argc, char *argv[])&#123; ros::init(argc, argv, &quot;hello&quot;); ros::NodeHandle nh; /* 使用ros::param来设置参数 */ //1.全局 ros::param::set(&quot;/radiusA&quot;,100); //2.相对 ros::param::set(&quot;radiusA&quot;,100); //3.私有 ros::param::set(&quot;~radiusA&quot;,100); /* 使用NodeHandle设置参数 */ //全局 nh.setParam(&quot;/radius_nh_A&quot;,1000); //相对 nh.setParam(&quot;radius_nh_A&quot;,1000); //私有 ros::NodeHandle nh_private(&quot;~&quot;); nh_private.setParam(&quot;radius_nh_A&quot;,1000); return 0;&#125; python123456789101112131415#! /usr/bin/env pythonimport rospyif __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;hello&quot;) &quot;&quot;&quot; 设置不同类型参数 &quot;&quot;&quot; #全局 rospy.set_param(&quot;/radius&quot;,100) #相对 rospy.set_param(&quot;radiusB&quot;,100) #私有 rospy.set_param(&quot;~radiusC&quot;,100) ros常用组件tf坐标变换坐标变换消息通过命令行rosmsg info geometry_msgs访问geometry消息 静态坐标变换发布方发布坐标系的相对关系 订阅方订阅发布的消息，再传入坐标点信息(可以写死)，然后借助于 tf 实现坐标变换，并将结果输出 c++实现发布方123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;ros/ros.h&quot;#include &quot;tf2_ros/static_transform_broadcaster.h&quot;#include &quot;geometry_msgs/TransformStamped.h&quot;#include &quot;tf2/LinearMath/Quaternion.h&quot;/* 需求：发布两个坐标系之间的相对关系 流程： 1.包含的头文件 2.设置编码 初始化ros节点 NodeHandle 3.创建发布对象 4.组织被发布的消息 5.发布数据 6。spin() */int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv, &quot;static_pub&quot;); ros::NodeHandle nh; tf2_ros::StaticTransformBroadcaster pub; geometry_msgs::TransformStamped tfs; tfs.header.stamp = ros::Time::now(); tfs.header.frame_id = &quot;base_link&quot;;//相对坐标系关系中被参考的那个 tfs.child_frame_id = &quot;laser&quot;; tfs.transform.translation.x = 0.2; tfs.transform.translation.y = 0.0; tfs.transform.translation.z = 0.5; //需要根据欧拉角转换 tf2::Quaternion qtn;//创建四元数对象 //向该对象设置欧拉表，这个对象可以将欧拉角转换成四元数 qtn.setRPY(0,0,0);//欧拉角的单位是弧度 tfs.transform.rotation.x=qtn.getX(); tfs.transform.rotation.y=qtn.getY(); tfs.transform.rotation.z=qtn.getZ(); tfs.transform.rotation.w=qtn.getW(); pub.sendTransform(tfs); ros::spin(); return 0;&#125; 订阅方1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &quot;ros/ros.h&quot;#include &quot;tf2_ros/transform_listener.h&quot;#include &quot;tf2_ros/buffer.h&quot;#include &quot;geometry_msgs/PointStamped.h&quot;#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;/* 订阅方实现:订阅发布的坐标系相对关系，传入一个座标点，调用tf实现转换 流程： 1.包含头文件 2.设置编码，节点初始化 NodeHandle(必须的) 3.创建订阅对象----》订阅坐标系相对关系 4.组织座标点数据 5.转换算法，需要调用tf内置实现 6.最后输出 */int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv, &quot;static_sub&quot;); ros::NodeHandle nh; //创建订阅对象 //3—1.创建一个buffer缓存 tf2_ros::Buffer buffer; //3-2在创建监听对象(监听对象可以将订阅的数据存入buffer) tf2_ros::TransformListener listener(buffer); geometry_msgs::PointStamped ps; ps.header.frame_id = &quot;laser&quot;; ps.header.stamp = ros::Time::now(); ps.point.x = 2.0; ps.point.y = 3.0; ps.point.z = 5.0; //转换算法 //添加休眠 // ros::Duration(2).sleep(); ros::Rate rate(10); while (ros::ok()) &#123; //核心代码实现 ----将ps转换成相对于base_link的座标点 geometry_msgs::PointStamped ps_out; /* 调用了buffer的转换函数transform 参数1：被转换的坐标点 参数2：目标坐标系 返回值：输出的坐标点 ps1:调用时必须包含头文件 tf2_geometry_msgs/tf2_geometry_msgs.h ps2：运行时存在的问题，抛出一个异常base_link不存在 原因：订阅数据是耗时操作，可能在调用transform转换函数时，坐标系的相对关系还没有订阅到，因此出现异常 解决： 方案1：在调用转换函数前执行休眠 方案2：异常处理 */ try &#123; /* code */ ps_out = buffer.transform(ps,&quot;base_link&quot;); ROS_INFO(&quot;转换后的坐标值：(%.2f,%.2f,%.2f),参考的坐标系:%s&quot;, ps_out.point.x, ps_out.point.y, ps_out.point.z, ps_out.header.frame_id.c_str()); &#125; catch(const std::exception&amp; e) &#123; // std::cerr &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; ROS_INFO(&quot;异常消息：%s&quot;,e.what()); &#125; rate.sleep(); ros::spinOnce(); &#125; return 0;&#125; python实现发布方12345678910111213141516171819202122232425262728293031323334353637383940#! /usr/bin/env pythonimport rospyimport tf2_rosimport tf_conversionsimport tffrom geometry_msgs.msg import TransformStamped&quot;&quot;&quot; 发布方：发布两个坐标系的相对关系(车辆底盘 ---base_link和雷达 ---laser) 流程： 1.导包 2.初始化ros节点 3.创建发布对象 4.组织被发布的数据 5.发布数据 6.spin() &quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;static_pub_p&quot;) pub = tf2_ros.StaticTransformBroadcaster() ts = TransformStamped() #header ts.header.stamp = rospy.Time.now() ts.header.frame_id = &quot;base_link&quot; #child frame ts.child_frame_id = &quot;laser&quot; #相对关系(偏移与四元数) ts.transform.translation.x = 0.2 ts.transform.translation.y = 0.0 ts.transform.translation.z = 0.5 #4.1先从欧拉角转化成四元数 qtn = tf_conversions.transformations.quaternion_from_euler(0,0,0) #4.2再设置四元数 ts.transform.rotation.x = qtn[0] ts.transform.rotation.y = qtn[1] ts.transform.rotation.z = qtn[2] ts.transform.rotation.w = qtn[3] pub.sendTransform(ts) rospy.spin() 订阅方123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#! /usr/bin/env python# from ast import Expressionimport rospyimport tf2_rosfrom tf2_geometry_msgs import tf2_geometry_msgs# from tf2_geometry_msgs import PointStamped&quot;&quot;&quot; 订阅方实现:订阅坐标变换，传入被转换的坐标点，调用转换算法 流程： 1.导包 2.初始化 3.创建订阅对象 4.组织被转换的坐标点 5.转换逻辑实现,调用tf封装的算法 6.输出结果 7.spin()|spinonce() &quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;static_sub_p&quot;) #创建订阅对象 #3-1.创建缓存对象 buffer = tf2_ros.Buffer() #3-2.创建订阅对象(将缓存传入) sub = tf2_ros.TransformListener(buffer) ps = tf2_geometry_msgs.PointStamped() ps.header.stamp = rospy.Time.now() ps.header.frame_id = &quot;laser&quot; ps.point.x = 2.0 ps.point.y = 3.0 ps.point.z = 5.0 rate = rospy.Rate(10) while not rospy.is_shutdown(): #转换实现 try: ps_out = buffer.transform(ps,&quot;base_link&quot;) rospy.loginfo(&quot;转换后的坐标：(%.2f,%.2f,%.2f),参考的坐标系：%s&quot;, ps_out.point.x, ps_out.point.y, ps_out.point.z, ps_out.header.frame_id) except Exception as e: rospy.logwarn(&quot;错误提示：%s&quot;, e) rate.sleep() 动态坐标变换c++实现发布方1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &quot;ros/ros.h&quot;#include &quot;turtlesim/Pose.h&quot;#include &quot;tf2_ros/transform_broadcaster.h&quot;#include &quot;geometry_msgs/TransformStamped.h&quot;#include &quot;tf2/LinearMath/Quaternion.h&quot;/* 发布方实现：需要订阅乌龟的位姿信息，转换成相对于窗体的坐标关系，并发布 准备： 话题：/turtle1/pose 消息：/turtlesim/Pose 流程： 1.包含头文件 2.设置编码，初始化，nodehandel创建 3.创建订阅对象，订阅/turtle1/pose 4.回调函数处理订阅的消息，将位姿信息转换成坐标相关关系并发布(关注) 5.spin() */void doPose(const turtlesim::Pose::ConstPtr&amp; pose)&#123; //获取位姿信息，转换成坐标系相对关系(核心)，并发布 //a.创建发布对象 static tf2_ros::TransformBroadcaster pub; //b.组织被发布的数据 geometry_msgs::TransformStamped ts; ts.header.frame_id = &quot;world&quot;; ts.header.stamp = ros::Time::now(); ts.child_frame_id = &quot;turtle1&quot;; //坐标系偏移量 ts.transform.translation.x = pose-&gt;x; ts.transform.translation.y = pose-&gt;y; ts.transform.translation.z = 0; //坐标系四元数 /* 位姿信息中没有四元数，但是有偏航角度，又已知乌龟是2D，没有翻滚与俯仰角度，所以可以得出乌龟的欧拉角0，0，theta */ tf2::Quaternion qtn; qtn.setRPY(0, 0, pose-&gt;theta); ts.transform.rotation.x = qtn.getX(); ts.transform.rotation.y = qtn.getY(); ts.transform.rotation.z = qtn.getZ(); ts.transform.rotation.w = qtn.getW(); pub.sendTransform(ts);&#125;int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv,&quot;dynamic_pub&quot;); ros::NodeHandle nh; ros::Subscriber sub = nh.subscribe(&quot;turtle1/pose&quot;,100,doPose); ros::spin(); return 0;&#125; 订阅方12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &quot;ros/ros.h&quot;#include &quot;tf2_ros/transform_listener.h&quot;#include &quot;tf2_ros/buffer.h&quot;#include &quot;geometry_msgs/PointStamped.h&quot;#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;/* 订阅方实现:订阅发布的坐标系相对关系，传入一个座标点，调用tf实现转换 流程： 1.包含头文件 2.设置编码，节点初始化 NodeHandle(必须的) 3.创建订阅对象----》订阅坐标系相对关系 4.组织座标点数据 5.转换算法，需要调用tf内置实现 6.最后输出 */int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv, &quot;static_sub&quot;); ros::NodeHandle nh; //创建订阅对象 //3—1.创建一个buffer缓存 tf2_ros::Buffer buffer; //3-2在创建监听对象(监听对象可以将订阅的数据存入buffer) tf2_ros::TransformListener listener(buffer); geometry_msgs::PointStamped ps; //参考的坐标系 ps.header.frame_id = &quot;turtle1&quot;; //时间戳 ps.header.stamp = ros::Time(0.0); ps.point.x = 2.0; ps.point.y = 3.0; ps.point.z = 5.0; //转换算法 //添加休眠 // ros::Duration(2).sleep(); ros::Rate rate(10); while (ros::ok()) &#123; //核心代码实现 ----将ps转换成相对于base_link的座标点 geometry_msgs::PointStamped ps_out; /* 调用了buffer的转换函数transform 参数1：被转换的坐标点 参数2：目标坐标系 返回值：输出的坐标点 ps1:调用时必须包含头文件 tf2_geometry_msgs/tf2_geometry_msgs.h ps2：运行时存在的问题，抛出一个异常base_link不存在 原因：订阅数据是耗时操作，可能在调用transform转换函数时，坐标系的相对关系还没有订阅到，因此出现异常 解决： 方案1：在调用转换函数前执行休眠 方案2：异常处理 */ try &#123; /* code */ ps_out = buffer.transform(ps,&quot;world&quot;); ROS_INFO(&quot;转换后的坐标值：(%.2f,%.2f,%.2f),参考的坐标系:%s&quot;, ps_out.point.x, ps_out.point.y, ps_out.point.z, ps_out.header.frame_id.c_str()); &#125; catch(const std::exception&amp; e) &#123; // std::cerr &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; ROS_INFO(&quot;异常消息：%s&quot;,e.what()); &#125; rate.sleep(); ros::spinOnce(); &#125; return 0;&#125; python实现订阅方123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#! /usr/bin/env pythonimport rospyfrom turtlesim.msg import Poseimport tf2_rosfrom geometry_msgs.msg import TransformStampedimport tf_conversions&quot;&quot;&quot; 发布方：订阅乌龟的位姿信息，转换成坐标系的相对关系，再发布 准备： 话题:/turtle1/pose 类型：/turtlesim/Pose 流程： 1.导包 2.初始化ros节点 3.创建订阅对象 4.回调函数处理订阅到的消息(核心) 5.spin() &quot;&quot;&quot;def doPose(pose): #创建发布坐标系相对关系的对象 pub = tf2_ros.TransformBroadcaster() #将pose位姿信息转化为坐标系相关关系消息 ts = TransformStamped() ts.header.frame_id = &quot;world&quot; ts.header.stamp = rospy.Time.now() ts.child_frame_id = &quot;turtle1&quot; # 子级坐标系相对于父级坐标系的偏移量 ts.transform.translation.x = pose.x ts.transform.translation.y = pose.y ts.transform.translation.z = 0 # 四元数 # 从欧拉角转换四元数 qtn = tf_conversions.transformations.quaternion_from_euler(0,0,pose.theta) ts.transform.rotation.x = qtn[0] ts.transform.rotation.y = qtn[1] ts.transform.rotation.z = qtn[2] ts.transform.rotation.w = qtn[3] #发布 pub.sendTransform(ts)if __name__ == &#x27;__main__&#x27;: # 1.初始化ros节点 rospy.init_node(&quot;dynamic_pub_p&quot;) # 2.创建订阅对象 sub = rospy.Subscriber(&quot;/turtle1/pose&quot;,Pose,doPose,queue_size=100) rospy.spin() 订阅方12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#! /usr/bin/env python# from ast import Expressionimport rospyimport tf2_rosfrom tf2_geometry_msgs import tf2_geometry_msgs# from tf2_geometry_msgs import PointStamped&quot;&quot;&quot; 订阅方实现:订阅坐标变换，传入被转换的坐标点，调用转换算法 流程： 1.导包 2.初始化 3.创建订阅对象 4.组织被转换的坐标点 5.转换逻辑实现,调用tf封装的算法 6.输出结果 7.spin()|spinonce() &quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;static_sub_p&quot;) #创建订阅对象 #3-1.创建缓存对象 buffer = tf2_ros.Buffer() #3-2.创建订阅对象(将缓存传入) sub = tf2_ros.TransformListener(buffer) ps = tf2_geometry_msgs.PointStamped() #时间戳 ---0 ps.header.stamp = rospy.Time() ps.header.frame_id = &quot;turtle1&quot; ps.point.x = 2.0 ps.point.y = 3.0 ps.point.z = 5.0 rate = rospy.Rate(10) while not rospy.is_shutdown(): #转换实现 try: ps_out = buffer.transform(ps,&quot;world&quot;) rospy.loginfo(&quot;转换后的坐标：(%.2f,%.2f,%.2f),参考的坐标系：%s&quot;, ps_out.point.x, ps_out.point.y, ps_out.point.z, ps_out.header.frame_id) except Exception as e: rospy.logwarn(&quot;错误提示：%s&quot;, e) rate.sleep() 多坐标变换c++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &quot;ros/ros.h&quot;#include &quot;tf2_ros/transform_listener.h&quot;#include &quot;tf2_ros/buffer.h&quot;#include &quot;geometry_msgs/PointStamped.h&quot;#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;#include &quot;geometry_msgs/TransformStamped.h&quot;/* 订阅方实现:1.计算son1与son2的相对关系 2.计算son1中的某个坐标点在son2中的坐标值 流程： 1.包含头文件 2.编码， 初始化 NodeHandle 3.创建订阅对象 4.编写解析逻辑 5.spinOnce() */int main(int argc, char *argv[])&#123; // 2.编码， 初始化 NodeHandle setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv,&quot;tfs_sub&quot;); ros::NodeHandle nh; // 3.创建订阅对象 tf2_ros::Buffer buffer; tf2_ros::TransformListener sub(buffer); // 4.编写解析逻辑 // 创建坐标点 geometry_msgs::PointStamped psAtSon1; psAtSon1.header.stamp = ros::Time::now(); psAtSon1.header.frame_id = &quot;son1&quot;; psAtSon1.point.x = 1.0; psAtSon1.point.y = 2.0; psAtSon1.point.z = 3.0; ros::Rate rate(10); while (ros::ok()) &#123; //核心实现 try &#123; /* A相对于B的坐标系关系 参数1：目标坐标系 参数2：源坐标系 参数3：ros::Time(0)取间隔最短的两个关系帧计算相对关系 返回值：geometry_msgs::TransformStamped源相对于坐标系的相对关系 */ // 计算son1与son2的相对关系 geometry_msgs::TransformStamped son1Toson2 = buffer.lookupTransform(&quot;son2&quot;,&quot;son1&quot;,ros::Time(0)); ROS_INFO(&quot;son1 相对于son2的信息:父级:%s,子级:%s,偏移量(%.2f,%.2f,%.2f)&quot;, son1Toson2.header.frame_id.c_str(), son1Toson2.child_frame_id.c_str(), son1Toson2.transform.translation.x, son1Toson2.transform.translation.y, son1Toson2.transform.translation.z ); // 计算son1中的某个坐标点在son2中的坐标值 geometry_msgs::PointStamped psAtSon2 = buffer.transform(psAtSon1,&quot;son2&quot;); ROS_INFO(&quot;坐标点在son2中的值(%.2f,%.2f,%.2f)&quot;, psAtSon2.point.x, psAtSon2.point.y, psAtSon2.point.z); &#125; catch(const std::exception&amp; e) &#123; ROS_INFO(&quot;错误提示：%s&quot;,e.what()); &#125; rate.sleep(); ros::spinOnce(); &#125; // 5.spinOnce() return 0;&#125; python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#! /usr/bin/env pythonimport rospyimport tf2_rosfrom tf2_geometry_msgs import tf2_geometry_msgsfrom geometry_msgs.msg import TransformStamped# from tf2_geometry_msgs import PointStampedif __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;static_sub_p&quot;) #创建订阅对象 #3-1.创建缓存对象 buffer = tf2_ros.Buffer() #3-2.创建订阅对象(将缓存传入) sub = tf2_ros.TransformListener(buffer) ps = tf2_geometry_msgs.PointStamped() #时间戳 ---0 ps.header.stamp = rospy.Time() ps.header.frame_id = &quot;son1&quot; ps.point.x = 1.0 ps.point.y = 2.0 ps.point.z = 3.0 rate = rospy.Rate(10) while not rospy.is_shutdown(): #转换实现 try: #计算son1相对于son2的坐标关系 &quot;&quot;&quot; 参数1:目标坐标系 参数2:源坐标系 参数3:rospy.Time(0) --- 取时间间隔最近的两个坐标系帧(son1相对world与son2相对world) 返回值:son1与son2的坐标系关系 &quot;&quot;&quot; ts = buffer.lookup_transform(&quot;son2&quot;,&quot;son1&quot;,rospy.Time(0)) rospy.loginfo(&quot;父级坐标系:%s,子级坐标系：%s,偏移量(%.2f,%.2f,%.2f)&quot;, ts.header.frame_id, ts.child_frame_id, ts.transform.translation.x, ts.transform.translation.y, ts.transform.translation.z ) ps_out = buffer.transform(ps,&quot;son2&quot;) rospy.loginfo(&quot;转换后的坐标：(%.2f,%.2f,%.2f),参考的坐标系：%s&quot;, ps_out.point.x, ps_out.point.y, ps_out.point.z, ps_out.header.frame_id) except Exception as e: rospy.logwarn(&quot;错误提示：%s&quot;, e) rate.sleep() 坐标系关系查看在运行坐标系的代码后，执行rosrun tf2_tools *.py，evince *.pdf 实操C++生成新乌龟12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;ros/ros.h&quot;#include &quot;turtlesim/Spawn.h&quot;/* 需求：向服务端发送请求，生成一只新乌龟 话题：/spawn 消息：turtlesin/Spawn 1.包含头文件 2.初始化ros节点 3.创建节点句柄 4.创建客户端对象 5.组织数据并发送 6.处理响应 */int main(int argc, char *argv[])&#123; setlocale(LC_ALL,&quot;&quot;); ros::init(argc,argv,&quot;service_call&quot;); ros::NodeHandle nh; ros::ServiceClient client = nh.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;); turtlesim::Spawn spawn; //组织请求数据 spawn.request.x = 1.0; spawn.request.y = 4.0; spawn.request.theta = 1.57; spawn.request.name = &quot;turtle2&quot;; //发送请求 //判断服务器状态 // ros::service::waitForService(&quot;/spawn&quot;); client.waitForExistence(); bool flag = client.call(spawn);//flag是用来接收响应状态的，响应结果也会被设置进spawn对象 if (flag)&#123; ROS_INFO(&quot;乌龟生成成功，新乌龟叫:%s&quot;,spawn.response.name.c_str()); &#125; else&#123; ROS_INFO(&quot;请求失败&quot;); &#125; return 0;&#125; 坐标发布123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &quot;ros/ros.h&quot;#include &quot;turtlesim/Pose.h&quot;#include &quot;tf2_ros/transform_broadcaster.h&quot;#include &quot;geometry_msgs/TransformStamped.h&quot;#include &quot;tf2/LinearMath/Quaternion.h&quot;/* 发布方实现：需要订阅乌龟的位姿信息，转换成相对于窗体的坐标关系，并发布 准备： 话题：/turtle1/pose 消息：/turtlesim/Pose 流程： 1.包含头文件 2.设置编码，初始化，nodehandel创建 3.创建订阅对象，订阅/turtle1/pose 4.回调函数处理订阅的消息，将位姿信息转换成坐标相关关系并发布(关注) 5.spin() *///声明变量接收传递的参数std::string turtle_name;void doPose(const turtlesim::Pose::ConstPtr&amp; pose)&#123; //获取位姿信息，转换成坐标系相对关系(核心)，并发布 //a.创建发布对象 static tf2_ros::TransformBroadcaster pub; //b.组织被发布的数据 geometry_msgs::TransformStamped ts; ts.header.frame_id = &quot;world&quot;; ts.header.stamp = ros::Time::now(); //关键点2动态传入 ts.child_frame_id = turtle_name; // ts.child_frame_id = &quot;turtle1&quot;; //坐标系偏移量 ts.transform.translation.x = pose-&gt;x; ts.transform.translation.y = pose-&gt;y; ts.transform.translation.z = 0; //坐标系四元数 /* 位姿信息中没有四元数，但是有偏航角度，又已知乌龟是2D，没有翻滚与俯仰角度，所以可以得出乌龟的欧拉角0，0，theta */ tf2::Quaternion qtn; qtn.setRPY(0, 0, pose-&gt;theta); ts.transform.rotation.x = qtn.getX(); ts.transform.rotation.y = qtn.getY(); ts.transform.rotation.z = qtn.getZ(); ts.transform.rotation.w = qtn.getW(); pub.sendTransform(ts);&#125;int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv,&quot;dynamic_pub&quot;); ros::NodeHandle nh; /* 解析launch文件通过args传入的参数 */ if(argc != 2)&#123; ROS_ERROR(&quot;清传入一个参数&quot;); return 1; &#125;else&#123; turtle_name = argv[1]; &#125; //关键点1：订阅的话题名称，turtle1/turtle2 ros::Subscriber sub = nh.subscribe(turtle_name + &quot;/pose&quot;,100,doPose); ros::spin(); return 0;&#125; 速度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &quot;ros/ros.h&quot;#include &quot;tf2_ros/transform_listener.h&quot;#include &quot;tf2_ros/buffer.h&quot;#include &quot;geometry_msgs/PointStamped.h&quot;#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;#include &quot;geometry_msgs/TransformStamped.h&quot;#include &quot;geometry_msgs/Twist.h&quot;// #include &quot;geometry_msgs/&quot;/* 需求：换算出turtle1相对于turtle2的关系 需求2：计算角速度和线速度并发布 */int main(int argc, char *argv[])&#123; // 2.编码， 初始化 NodeHandle setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv,&quot;tfs_sub&quot;); ros::NodeHandle nh; // 3.创建订阅对象 tf2_ros::Buffer buffer; tf2_ros::TransformListener sub(buffer); //1.创建发布对象 ros::Publisher pub = nh.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle2/cmd_vel&quot;,100); // 4.编写解析逻辑 ros::Rate rate(10); while (ros::ok()) &#123; //核心实现 try &#123; /* A相对于B的坐标系关系 参数1：目标坐标系 参数2：源坐标系 参数3：ros::Time(0)取间隔最短的两个关系帧计算相对关系 返回值：geometry_msgs::TransformStamped源相对于坐标系的相对关系 */ // 计算son1与son2的相对关系 geometry_msgs::TransformStamped son1Toson2 = buffer.lookupTransform(&quot;turtle2&quot;,&quot;turtle1&quot;,ros::Time(0)); // ROS_INFO(&quot;turtle1 相对于turtle2的信息:父级:%s,子级:%s,偏移量(%.2f,%.2f,%.2f)&quot;, // son1Toson2.header.frame_id.c_str(), // son1Toson2.child_frame_id.c_str(), // son1Toson2.transform.translation.x, // son1Toson2.transform.translation.y, // son1Toson2.transform.translation.z // ); // 2.根据相对计算并组织速度消息 geometry_msgs::Twist twist; /* 组织速度只需要设置线速度的x与角速度的z x=系数*sqrt(y^2+x^2) z=系数*反正切(对边，邻边) */ twist.linear.x =0.5*sqrt(pow(son1Toson2.transform.translation.x,2)+pow(son1Toson2.transform.translation.y,2)); twist.angular.z =4*atan2(son1Toson2.transform.translation.y,son1Toson2.transform.translation.x); // 3.发布 pub.publish(twist); &#125; catch(const std::exception&amp; e) &#123; ROS_INFO(&quot;错误提示：%s&quot;,e.what()); &#125; rate.sleep(); ros::spinOnce(); &#125; // 5.spinOnce() return 0;&#125; python生成新乌龟1234567891011121314151617181920212223242526272829#! /usr/bin/env pythonimport rospyfrom turtlesim.srv import Spawn,SpawnRequest,SpawnResponse&quot;&quot;&quot; 需求：向参数服务器发送请求生成一只乌龟 话题：/spawn 消息:turtlesim/Spawn 1.导包 2.初始化ros节点 3.创建服务的客户端对象 4.组织数据并发送请求 5.处理响应结果 &quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;service_call_p&quot;) client = rospy.ServiceProxy(&quot;/spawn&quot;,Spawn) request = SpawnRequest() request.x = 4.5 request.y = 2.0 request.theta = -3 request.name = &quot;turtle2&quot; client.wait_for_service() try: response = client.call(request) rospy.loginfo(&quot;生成乌龟的名字叫%s&quot;,response.name) except Exception as e: rospy.logerr(&quot;请求处理失败&quot;) 速度发布12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#! /usr/bin/env pythonimport rospyfrom turtlesim.msg import Poseimport tf2_rosfrom geometry_msgs.msg import TransformStampedimport tf_conversionsimport sys&quot;&quot;&quot; 发布方：订阅乌龟的位姿信息，转换成坐标系的相对关系，再发布 准备： 话题:/turtle1/pose 类型：/turtlesim/Pose 流程： 1.导包 2.初始化ros节点 3.创建订阅对象 4.回调函数处理订阅到的消息(核心) 5.spin() &quot;&quot;&quot;#接受乌龟名称的遍历turtle_name = &quot;&quot;def doPose(pose): #创建发布坐标系相对关系的对象 pub = tf2_ros.TransformBroadcaster() #将pose位姿信息转化为坐标系相关关系消息 ts = TransformStamped() ts.header.frame_id = &quot;world&quot; ts.header.stamp = rospy.Time.now() ts.child_frame_id = turtle_name # 子级坐标系相对于父级坐标系的偏移量 ts.transform.translation.x = pose.x ts.transform.translation.y = pose.y ts.transform.translation.z = 0 # 四元数 # 从欧拉角转换四元数 qtn = tf_conversions.transformations.quaternion_from_euler(0,0,pose.theta) ts.transform.rotation.x = qtn[0] ts.transform.rotation.y = qtn[1] ts.transform.rotation.z = qtn[2] ts.transform.rotation.w = qtn[3] #发布 pub.sendTransform(ts)if __name__ == &#x27;__main__&#x27;: # 1.初始化ros节点 rospy.init_node(&quot;dynamic_pub_p&quot;) #解析传入的参数(现在传入几个参数? 文件全路径+传入的参数+节点名称+日志文件路径) if len(sys.argv) != 4: rospy.loginfo(&quot;参数个数不对&quot;) sys.exit(1) else: turtle_name = sys.argv[1] # 2.创建订阅对象 sub = rospy.Subscriber(turtle_name + &quot;/pose&quot;,Pose,doPose,queue_size=100) rospy.spin() 速度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#! /usr/bin/env pythonimport rospyimport tf2_rosfrom tf2_geometry_msgs import tf2_geometry_msgsfrom geometry_msgs.msg import TransformStamped,Twistimport mathif __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;static_sub_p&quot;) #创建订阅对象 #3-1.创建缓存对象 buffer = tf2_ros.Buffer() #3-2.创建订阅对象(将缓存传入) sub = tf2_ros.TransformListener(buffer) #创建速度消息发布对象 pub = rospy.Publisher(&quot;/turtle2/cmd_vel&quot;,Twist,queue_size=100) rate = rospy.Rate(10) while not rospy.is_shutdown(): #转换实现 try: #计算son1相对于son2的坐标关系 &quot;&quot;&quot; 参数1:目标坐标系 参数2:源坐标系 参数3:rospy.Time(0) --- 取时间间隔最近的两个坐标系帧(son1相对world与son2相对world) 返回值:son1与son2的坐标系关系 &quot;&quot;&quot; ts = buffer.lookup_transform(&quot;turtle2&quot;,&quot;turtle1&quot;,rospy.Time(0)) rospy.loginfo(&quot;父级坐标系:%s,子级坐标系：%s,偏移量(%.2f,%.2f,%.2f)&quot;, ts.header.frame_id, ts.child_frame_id, ts.transform.translation.x, ts.transform.translation.y, ts.transform.translation.z ) #组织Twist消息 twist = Twist() #线速度 = 系数 * 坐标系原点的间距= 系数 * (x^2+y^2)再开方 #角速度 = 系数 * 夹角 = 系数 +atn2(y,x) twist.linear.x = 0.5 *math.sqrt(math.pow(ts.transform.translation.x,2)+math.pow(ts.transform.translation.y,2)) twist.angular.z = 4 * math.atan2(ts.transform.translation.y,ts.transform.translation.x) #发布消息 pub.publish(twist) except Exception as e: rospy.logwarn(&quot;错误提示：%s&quot;, e) rate.sleep() rosbag命令行实现 录制：rosbag record -a -O 目标文件 查看rosbag info 文件名 回放rosbag play 文件名 编码实现c++写1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;ros/ros.h&quot;#include &quot;rosbag/bag.h&quot;#include &quot;std_msgs/String.h&quot;/* 需求：使用rosbag向磁盘文件写入数据（话题+消息） 流程： 1.导包 2.初始化 3.创建rosbag对象 4.打开文件流 5.写数据 6.关闭文件流 */int main(int argc, char *argv[])&#123; // 2.初始化 setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv, &quot;bag_writer&quot;); ros::NodeHandle nh; // 3.创建rosbag对象 rosbag::Bag bag; // 4.打开文件流 bag.open(&quot;hello.bag&quot;,rosbag::BagMode::Write); // 5.写数据 std_msgs::String msg; msg.data = &quot;hello xxxxx&quot;; /* 参数1话题 参数2时间戳 参数3消息 */ bag.write(&quot;/chatter&quot;,ros::Time::now(),msg); bag.write(&quot;/chatter&quot;,ros::Time::now(),msg); bag.write(&quot;/chatter&quot;,ros::Time::now(),msg); bag.write(&quot;/chatter&quot;,ros::Time::now(),msg); // 6.关闭文件流 bag.close(); return 0;&#125; 读1234567891011121314151617181920212223242526272829303132333435#include &quot;ros/ros.h&quot;#include &quot;rosbag/bag.h&quot;#include &quot;rosbag/view.h&quot;#include &quot;std_msgs/String.h&quot;/* 需求：使用rosbag读取磁盘上的bag文件 流程： 1.导包 2.初始化 3.创建rosbag对象 4.打开文件流(以读的方式打开) 5.写数据 6.关闭文件流 */int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv, &quot;bag_read&quot;); ros::NodeHandle nh; rosbag::Bag bag; bag.open(&quot;hello.bag&quot;,rosbag::BagMode::Read); //可以先获取消息的集合，在迭代取出消息的字段 for(auto&amp;&amp; m :rosbag::View(bag))&#123; std::string topic = m.getTopic(); ros::Time time = m.getTime(); std_msgs::StringPtr p = m.instantiate&lt;std_msgs::String&gt;(); ROS_INFO(&quot;解析的内容，话题:%s,时间戳：%.2f,消息值：%s&quot;, topic.c_str(), time.toSec(), p-&gt;data.c_str()); &#125; bag.close(); return 0;&#125; python写123456789101112131415161718192021222324252627282930#! usr/bin/env pythonimport rospyimport rosbagfrom std_msgs.msg import String&quot;&quot;&quot; 需求:写出消息数据到磁盘上的bag文件 流程： 1.导包 2.初始化 3.创建rosbag对象并打开文件流 4.写数据 5.关闭流 &quot;&quot;&quot;if __name__ == &quot;__main__&quot;: # 2.初始化 rospy.init_node(&quot;write_bag_p&quot;) # 3.创建rosbag对象并打开文件流 bag = rosbag.Bag(&quot;hello_p.bag&quot;,&quot;w&quot;) # 4.写数据 msg = String() msg.data = &quot;hello bag&quot; bag.write(&quot;/liaotian&quot;,msg) bag.write(&quot;/liaotian&quot;,msg) bag.write(&quot;/liaotian&quot;,msg) bag.write(&quot;/liaotian&quot;,msg) bag.write(&quot;/liaotian&quot;,msg) # 5.关闭流 bag.close() 读12345678910111213141516171819202122#! /usr/bin/env pythonimport rospyimport rosbagfrom std_msgs.msg import String&quot;&quot;&quot; 需求:读取磁盘上的bag文件 流程： 1.导包 2.初始化 3.创建rosbag对象并打开文件流 4.读数据 5.关闭流 &quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;: rospy.init_node(&quot;read_bag_p&quot;) bag = rosbag.Bag(&quot;hello_p.bag&quot;,&quot;r&quot;) msgs = bag.read_messages(&quot;/liaotian&quot;) for topic,msg,time in msgs: rospy.loginfo(&quot;话题%s,消息:%s,时间:%s&quot;,topic,msg.data,time) bag.close() rqt工具箱 启动 rqt 可以通过 plugins 添加所需的插件 rqt_console 是 ROS 中用于显示和过滤日志的图形化插件，可以在 rqt 的 plugins 中添加，或者使用rqt_console启动 rqt_plot是图形绘制插件，可以以 2D 绘图的方式绘制发布在 topic 上的数据 rqt_bag录制和重放 bag 文件的图形化插件 机器人仿真优缺点优点 低成本 高效 高安全性 缺点 不能完全仿真真实环境 存在失真现象 urdf语法robot,link123456789101112131415161718192021222324252627282930&lt;!-- 需求设置不同形状的机器人部件 --&gt;&lt;robot name=&quot;mycar&quot;&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;!-- 可视化标签 --&gt; &lt;!-- 1.形状 --&gt; &lt;geometry&gt; &lt;!-- 立方体 --&gt; &lt;!-- &lt;box size=&quot;0.3 0.2 0.1&quot; /&gt; --&gt; &lt;!-- 圆柱 --&gt; &lt;!-- &lt;cylinder radius=&quot;0.1&quot; length=&quot;2&quot;/&gt; --&gt; &lt;!-- 球体 --&gt; &lt;!-- &lt;sphere radius=&quot;1&quot;/&gt; --&gt; &lt;!-- 皮肤 --&gt; &lt;mesh filename=&quot;package://urdf01_rviz/meshes/autolabor_mini.stl&quot; /&gt; &lt;/geometry&gt; &lt;!-- 2.偏移量和倾斜弧度 --&gt; &lt;!-- xyz设置机器人在xyz轴的偏移量 rpy设置倾斜弧度xyz翻滚扶养偏航 --&gt; &lt;!-- &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; --&gt; &lt;origin xyz=&quot;0 0.0 0.0&quot; rpy=&quot;1.57 0.0 1.57&quot;/&gt; &lt;!-- 3.颜色 --&gt; &lt;material name=&quot;car_color&quot;&gt; &lt;color rgba=&quot;0 0.0 1.0 1&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt;&lt;/robot&gt; joint123456789101112131415161718192021222324252627282930&lt;robot name=&quot;mycar&quot;&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;box size=&quot;0.3 0.2 0.1&quot; /&gt; &lt;/geometry&gt; &lt;origin xyz=&quot;0 0.0 0&quot; rpy=&quot;0 0.0 0&quot;/&gt; &lt;material name=&quot;car_color&quot;&gt; &lt;color rgba=&quot;0 0.0 1.0 0.8&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;link name=&quot;camera&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;box size=&quot;0.02 0.05 0.05&quot; /&gt; &lt;/geometry&gt; &lt;origin xyz=&quot;0 0.0 0.025&quot; rpy=&quot;0 0.0 0&quot;/&gt; &lt;material name=&quot;camera_color&quot;&gt; &lt;color rgba=&quot;0.5 0.0 1.0 1&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;joint name=&quot;camera2base&quot; type=&quot;continuous&quot;&gt; &lt;parent link=&quot;base_link&quot;/&gt; &lt;child link=&quot;camera&quot;/&gt; &lt;origin xyz=&quot;0.12 0.0 0.05&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;axis xyz=&quot;0.0 0.0 1.0&quot;/&gt; &lt;/joint&gt;&lt;/robot&gt; xacro语法定义，调用，运算12345678910&lt;robot name=&quot;mycar&quot; xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt; &lt;!-- 1属性定义 --&gt; &lt;xacro:property name=&quot;PI&quot; value=&quot;3.1415927&quot; /&gt; &lt;xacro:property name=&quot;radius&quot; value=&quot;0.03&quot; /&gt; &lt;!-- 属性调用 --&gt; &lt;myusePropertyxx name=&quot;$&#123;PI&#125;&quot; /&gt; &lt;myusePropertyxx name=&quot;$&#123;radius&#125;&quot; /&gt; &lt;!-- 算术运算 --&gt; &lt;myusePropertyxx name=&quot;$&#123;PI / 2&#125;&quot; /&gt; &lt;/robot&gt; 封装，宏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;robot name=&quot;mycar&quot; xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt;&lt;!-- 上节案例问题： 1.代码复用 ====Xacro宏(函数) 2.参数设计= ===Xacro变量 --&gt; &lt;!-- 属性封装 --&gt; &lt;xacro:property name=&quot;wheel_radius&quot; value=&quot;0.0325&quot; /&gt; &lt;xacro:property name=&quot;wheel_length&quot; value=&quot;0.0015&quot; /&gt; &lt;xacro:property name=&quot;PI&quot; value=&quot;3.1415927&quot; /&gt; &lt;xacro:property name=&quot;base_link_length&quot; value=&quot;0.08&quot; /&gt; &lt;xacro:property name=&quot;lidi_space&quot; value=&quot;0.015&quot; /&gt; &lt;!-- 宏 --&gt; &lt;xacro:macro name=&quot;wheel_func&quot; params=&quot;wheel_name flag&quot; &gt; &lt;link name=&quot;$&#123;wheel_name&#125;_wheel&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;cylinder radius=&quot;$&#123;wheel_radius&#125;&quot; length=&quot;$&#123;wheel_length&#125;&quot; /&gt; &lt;/geometry&gt; &lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;$&#123;PI / 2&#125; 0 0&quot; /&gt; &lt;material name=&quot;wheel_color&quot;&gt; &lt;color rgba=&quot;0 0 0 0.3&quot; /&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;!-- 3.2joint --&gt; &lt;joint name=&quot;$&#123;wheel_name&#125;2link&quot; type=&quot;continuous&quot;&gt; &lt;parent link=&quot;base_link&quot; /&gt; &lt;child link=&quot;$&#123;wheel_name&#125;_wheel&quot; /&gt; &lt;!-- x 无偏移 y 车体半径 z z= 车体高度 / 2 + 离地间距 - 车轮半径 --&gt; &lt;origin xyz=&quot;0 $&#123;0.1 * flag&#125; $&#123;(base_link_length / 2 + lidi_space - wheel_radius) * -1&#125;&quot; rpy=&quot;0 0 0&quot; /&gt; &lt;axis xyz=&quot;0 1 0&quot; /&gt; &lt;/joint&gt; &lt;/xacro:macro&gt; &lt;!-- 调用语法 --&gt; &lt;xacro:wheel_func wheel_name=&quot;left&quot; flag=&quot;1&quot; /&gt; &lt;xacro:wheel_func wheel_name=&quot;right&quot; flag=&quot;-1&quot; /&gt;&lt;/robot&gt; 包含123456&lt;robot name=&quot;mycar&quot; xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt; &lt;!-- 演示文件包含 --&gt; &lt;xacro:include filename=&quot;demo02_field.urdf.xacro&quot; /&gt; &lt;xacro:include filename=&quot;demo03_macro.urdf.xacro&quot; /&gt;&lt;/robot&gt; rviz控制机器人运动流程 添加配置文件 官方配置文件 编写launch文件 1234567891011121314151617&lt;launch&gt; &lt;!-- 将 urdf 文件内容设置进参数服务器 --&gt; &lt;!-- &lt;param name=&quot;robot_description&quot; textfile=&quot;$(find urdf01_rviz)/urdf/xacro/demo05_car_base.urdf&quot; /&gt; --&gt; &lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro $(find urdf01_rviz)/urdf/xacro/car.urdf.xacro&quot; /&gt; &lt;!-- 启动 rivz --&gt; &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz_test&quot; args=&quot;-d $(find urdf01_rviz)/config/show_mycar.rviz&quot; /&gt; &lt;!-- 启动机器人状态和关节状态发布节点 --&gt; &lt;node pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; name=&quot;robot_state_publisher&quot; /&gt; &lt;node pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; name=&quot;joint_state_publisher&quot; /&gt; &lt;!-- 集成arbotix运动控制节点,并且加载参数 --&gt; &lt;node pkg=&quot;arbotix_python&quot; type=&quot;arbotix_driver&quot; name=&quot;driver&quot; output=&quot;screen&quot;&gt; &lt;rosparam command=&quot;load&quot; file=&quot;$(find urdf01_rviz)/config/control.yaml&quot; /&gt; &lt;param name=&quot;sim&quot; value=&quot;true&quot; /&gt; &lt;/node&gt;&lt;/launch&gt; 启动launch文件控制小车运动 urdf集成gazebo基本流程 创建功能包 编写urdf文件 启动gazebo并显示模型 基本语法 如果是标准几何体：collision和link的 visual 属性设置一致 如果不是标准集合体则需要设置惯性矩阵 综合机器人运动控制运动控制基本流程: 为 joint 添加传动装置以及控制器 xacro文件集成 启动 gazebo并控制机器人运动 Rviz查看里程计信息 1rostopic pub -r 10 /cmd_vel geometry_msgs/Twist &#x27;linear: x: 0.2, y: 0, z: 0, angular: x: 0, y: 0, z: 0.5&#x27; 雷达信息仿真流程： 新建 Xacro 文件，配置雷达传感器信息 xacro 文件集成 启动仿真环境 Rviz 显示雷达数据 摄像头信息仿真流程： 新建 Xacro 文件，配置摄像头传感器信息 xacro 文件集成 启动仿真环境 Rviz 显示摄像头数据 kinect信息仿真流程： 新建 Xacro 文件，配置kinetic传感器信息 xacro 文件集成 启动仿真环境 Rviz 显示Kinect 数据 &#x3D;&#x3D;注意：在rviz中点云数据显示错位解决办法&#x3D;&#x3D; 12&lt;frameName&gt;support_depth&lt;/frameName&gt;&lt;node pkg=&quot;tf2_ros&quot; type=&quot;static_transform_publisher&quot; name=&quot;static_transform_publisher&quot; args=&quot;0 0 0 -1.57 0 -1.57 /support /support_depth&quot; /&gt; 12rosrun tf2_ros static_transform_publisher 0.1 0.0 0.3 0 0 0 /base_link /camera 偏航 俯仰 翻滚 机器人导航导航模块简介关键技术 全局地图 自身定位 路径规划 运动控制 环境感知 导航坐标系&#x3D;&#x3D;坐标系关系：map&gt;odom&gt;base_link或base_footprint&#x3D;&#x3D; 里程计特点 优点：连续，无跳变 缺点：累计误差 易产生误差： 路面不平，测速不准，车轮打滑 长时间，长距离运行会导致误差累积 传感器特点 优点：精准 缺点：跳变，且特征点较少时精度会降低 导航实现slam建图流程： 编写gampping节点相关launch文件 launch文件模板 启动 Gazebo 仿真环境 启动地图绘制的 launch 文件 启动键盘键盘控制节点，用于控制机器人运动建图 地图服务1234&lt;launch&gt; &lt;arg name=&quot;map&quot; default=&quot;nav.yaml&quot; /&gt; &lt;node pkg=&quot;map_server&quot; type=&quot;map_server&quot; name=&quot;map_server&quot; args=&quot;$(find nav_demo)/map/$(arg map)&quot; /&gt;&lt;/launch&gt; 12345&lt;launch&gt; &lt;arg name=&quot;filename&quot; value=&quot;$(find nav_demo)/map/nav&quot; /&gt; &lt;node name=&quot;map_save&quot; pkg=&quot;map_server&quot; type=&quot;map_saver&quot; args=&quot;-f $(arg filename)&quot; /&gt;&lt;/launch&gt; amcl定位 launch文件编写 导入模板 123roscd amclls examplesgedit examples/amcl_diff.launch movebase路径规划代价地图组成(多层叠加) 静态层 —–slam绘制的静态地图 障碍物层 —导航中传感器感知的障碍物 膨胀层 —–为了避免碰撞设置的安全区 自定义层 —-根据业务自设置的地图数据 配置文件地址 1配置文件书写正确，xml没有问题时，且已经souce和编译，rosrun报[rosrun] Couldn&#x27;t find executable named use_plus below /home/zhuwencheng/demo06_ws/src/demo03_plugin重启vscode就可以正常运行 参数配置技巧 全局代价地图可以将膨胀半径和障碍物系数设置的偏大一些 本地代价地图可以将膨胀半径和障碍物系数设置的偏小一些 机器人自主移动建图12345678&lt;!-- 集成slam与导航，实现机器人自主移动的地图构建 --&gt;&lt;launch&gt; &lt;!-- 1.slam实现 --&gt; &lt;include file=&quot;$(find nav_demo)/launch/nav01_slam.launch&quot; /&gt; &lt;!-- 2.导航中的movebase实现 --&gt; &lt;include file=&quot;$(find nav_demo)/launch/nav05_path.launch&quot; /&gt; &lt;/launch&gt; 导航相关消息 地图：rosmsg info nav_msgs&#x2F;MapMetaData 里程计：rosmsg info nav_msgs&#x2F;Odometry 坐标变换：rosmsg info tf&#x2F;tfMessage 定位：rosmsg info geometry_msgs&#x2F;PoseArray 目标点及路径规划：rosmsg info move_base_msgs&#x2F;MoveBaseActionGoal 雷达：rosmsg info sensor_msgs&#x2F;LaserScan 相机： rosmsg info sensor_msgs&#x2F;Imag rosmsg info sensor_msgs&#x2F;CompressedImage rosmsg info sensor_msgs&#x2F;PointCloud2 ros进阶action通信自定义action文件12345678#1.目标数据变量int32 num---#2.最终响应变量int32 result---#3.连续反馈变量float64 progress_bar action通信C++服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &quot;ros/ros.h&quot;#include &quot;actionlib/server/simple_action_server.h&quot;#include &quot;demo01_action/AddIntsAction.h&quot;/* 需求: 创建两个ROS节点，服务器和客户端， 客户端可以向服务器发送目标数据N（一个整型数据） 服务器会计算1到N之间所有整数的和，这是一个循环累加的过程，返回给客户端， 这是基于请求响应模式的， 又已知服务器从接收到请求到产生响应是一个耗时操作，每累加一次耗时0.1s， 为了良好的用户体验，需要服务器在计算过程中， 每累加一次，就给客户端响应一次百分比格式的执行进度，使用action实现。 流程： 1.包含头文件 2.初始化ros节点 3.创建NodeHandle 4.创建action服务对象 5.请求处理(a.解析提交的目标值；b.产生连续反馈；c.最终结果响应) ---回调函数 6.spin()回旋 */typedef actionlib::SimpleActionServer&lt;demo01_action::AddIntsAction&gt; Server;// 5.请求处理(a.解析提交的目标值；b.产生连续反馈；c.最终结果响应) ---回调函数void cb(const demo01_action::AddIntsGoalConstPtr &amp;goalPtr,Server* server)&#123; // a.解析提交的目标值 int goal_num = goalPtr -&gt; num; ROS_INFO(&quot;客户端提交的目标值是:%d&quot;,goal_num); // b.产生连续反馈 ros::Rate rate(10); int result = 0; for (int i = 1; i &lt;= goal_num; i++) &#123; result += i; rate.sleep(); //产生连续反馈 // void publishFeedback(const demo01_action::AddIntsFeedback &amp;feedback) demo01_action::AddIntsFeedback fb; fb.progress_bar = i /(double)goal_num; server-&gt;publishFeedback(fb); &#125; ROS_INFO(&quot;最终运行结果：%d&quot;,result); // c.最终结果响应 demo01_action::AddIntsResult r; r.result = result; server-&gt;setSucceeded(r);&#125;int main(int argc, char *argv[])&#123; // 2.初始化ros节点 setlocale(LC_ALL, &quot;&quot;); ros::init(argc,argv,&quot;addInts_server&quot;); // 3.创建NodeHandle ros::NodeHandle nh; // 4.创建action服务对象 /* SimpleActionServer(ros::NodeHandle n, std::string name, boost::function&lt;void (const demo01_action::AddIntsGoalConstPtr &amp;)&gt; execute_callback, bool auto_start) 参数1：NodeHandle 参数2：话题名称 参数3：回调函数 参数4：是否自动启动 */ Server server(nh,&quot;addInts&quot;,boost::bind(&amp;cb,_1,&amp;server),false); server.start();//如果auto_start为false，那么需要手动调用该函数启动服务 ROS_INFO(&quot;服务启动.....&quot;); // 5.请求处理(a.解析提交的目标值；b.产生连续反馈；c.最终结果响应) ---回调函数 // 6.spin()回旋 ros::spin(); return 0;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &quot;ros/ros.h&quot;#include &quot;actionlib/client/simple_action_client.h&quot;#include &quot;demo01_action/AddIntsAction.h&quot;/* 需求: 创建两个ROS 节点，服务器和客户端， 客户端可以向服务器发送目标数据N(一个整型数据)服务器会计算 1 到 N 之间所有整数的和, 这是一个循环累加的过程，返回给客户端，这是基于请求响应模式的， 又已知服务器从接收到请求到产生响应是一个耗时操作，每累加一次耗时0.1s， 为了良好的用户体验，需要服务器在计算过程中， 每累加一次，就给客户端响应一次百分比格式的执行进度，使用 action实现。 流程： 1.包含头文件 2.初始化ros节点 3.创建NodeHandle 4.创建action客户端对象 5.发送请求 a.连接建立 ----回调函数 b.处理连续反馈 ---回调函数 c.处理最终响应 ---回调函数 6.spin()回旋 *///相应成功时的回调void done_cb(const actionlib::SimpleClientGoalState &amp;state , const demo01_action::AddIntsResultConstPtr &amp;result)&#123; if(state.state_ == state.SUCCEEDED)&#123; ROS_INFO(&quot;响应成功，最终结果 = %d&quot;, result-&gt;result); &#125;else&#123; ROS_INFO(&quot;请求失败&quot;); &#125;&#125;// 激活回调void active_cb()&#123; ROS_INFO(&quot;客户端与服务端连接建立...&quot;);&#125;//连续反馈的回调void feedback_cb(const demo01_action::AddIntsFeedbackConstPtr &amp;feedback)&#123; ROS_INFO(&quot;连续反馈：%.2f&quot;,feedback-&gt;progress_bar);&#125;int main(int argc, char *argv[])&#123; // 2.初始化ros节点 setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv,&quot;addInts_client&quot;); // 3.创建NodeHandle ros::NodeHandle nh; // 4.创建action客户端对象 actionlib::SimpleActionClient&lt;demo01_action::AddIntsAction&gt; client(nh,&quot;addInts&quot;); // 5.发送请求 // 注意:先等待服务 ROS_INFO(&quot;等待服务器启动...&quot;); client.waitForServer(); // a.连接建立 ----回调函数 // b.处理连续反馈 ---回调函数 // c.处理最终响应 ---回调函数 /* void sendGoal(const demo01_action::AddIntsGoal &amp;goal, boost::function&lt;void (const actionlib::SimpleClientGoalState &amp;state, const demo01_action::AddIntsResultConstPtr &amp;result)&gt; done_cb, boost::function&lt;void ()&gt; active_cb, boost::function&lt;void (const demo01_action::AddIntsFeedbackConstPtr &amp;feedback)&gt; feedback_cb) */ // 参数1：设置目标值 demo01_action::AddIntsGoal goal; goal.num = 100; client.sendGoal(goal,&amp;done_cb,&amp;active_cb,&amp;feedback_cb); // 6.spin()回旋 ros::spin(); return 0;&#125; python服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#! /usr/bin/env pythonimport rospyimport actionlibfrom demo01_action.msg import *&quot;&quot;&quot; 需求: 创建两个ROS 节点，服务器和客户端， 客户端可以向服务器发送目标数据N(一个整型数据)服务器会计算 1 到 N 之间所有整数的和, 这是一个循环累加的过程，返回给客户端，这是基于请求响应模式的， 又已知服务器从接收到请求到产生响应是一个耗时操作,每累加一次耗时0.1s, 为了良好的用户体验，需要服务器在计算过程中， 每累加一次，就给客户端响应一次百分比格式的执行进度，使用 action实现。 流程： 1.导包 2.初始化ros节点 3.单独封装一个类 4.类中创建action 服务端对象 5.处理请求(a.解析目标值 b.发送连续反馈 c.响应最终结果) --回调函数 6.spin() &quot;&quot;&quot;# 4.类中创建action 服务端对象# 5.处理请求(a.解析目标值 b.发送连续反馈 c.响应最终结果) --回调函数class MyAction: def __init__(self): # (name, ActionSpec, execute_cb=None, auto_start=True) -&gt; None self.server = actionlib.SimpleActionServer(&quot;addInts&quot;,AddIntsAction,self.cb,False) self.server.start() rospy.loginfo(&quot;服务端启动...&quot;)# 回调函数# 参数：目标值 def cb(self,goal): # a.解析目标值 goal_num = goal.num rospy.loginfo(&quot;目标值:%d&quot;,goal_num) # b.发送连续反馈 rate = rospy.Rate(10) sum = 0 #接收求和的结果变量 rospy.loginfo(&quot;请求处理中&quot;) for i in range(1,goal_num+1): sum = sum+i rate.sleep() #发送连续反馈 fb_obj = AddIntsFeedback() fb_obj.progress_bar = i/goal_num self.server.publish_feedback(fb_obj) # c.响应最终结果 rospy.loginfo(&quot;响应最终结果：%d&quot;,sum) result = AddIntsResult() result.result =sum self.server.set_succeeded(result)if __name__ == &#x27;__main__&#x27;: # 1.导包 rospy.init_node(&quot;action_server_p&quot;) # 2.初始化ros节点 # 3.单独封装一个类 myAction = MyAction() # 6.spin() rospy.spin() 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# #! /usr/bin/env python# import rospy # import actionlib# from demo01_action.msg import *# &quot;&quot;&quot; # 需求:# 创建两个ROS 节点，服务器和客户端，# 客户端可以向服务器发送目标数据N(一个整型数据)服务器会计算 1 到 N 之间所有整数的和,# 这是一个循环累加的过程，返回给客户端，这是基于请求响应模式的，# 又已知服务器从接收到请求到产生响应是一个耗时操作,每累加一次耗时0.1s,# 为了良好的用户体验，需要服务器在计算过程中，# 每累加一次，就给客户端响应一次百分比格式的执行进度，使用 action实现。# 流程：# 1.导包# 2.初始化ros节点# 3.创建action客户端对象(等待服务启动)# 4.发送请求# a.激活处理# b.连续反馈处理# c.最终响应结果处理# 6.spin()# &quot;&quot;&quot;# def done_cb(status,result):# if status ==actionlib.GoalStatus.SUCCEEDED:# rospy.loginfo(&quot;最终响应结果：%d&quot;,result.result)# else:# rospy.loginfo(&quot;响应失败&quot;)# def active_cb():# rospy.loginfo(&quot;连接建立了&quot;)# def feedback_cb(feedback):# rospy.loginfo(&quot;当前进度：%.2f&quot;,feedback.progress_bar)# if __name__ == &#x27;__main__&#x27;:# # 2.初始化ros节点# rospy.init_node(&quot;action_client_p&quot;)# # 3.创建action客户端对象(等待服务启动)# client = actionlib.SimpleActionClient(&quot;addInts&quot;,AddIntsAction)# client.wait_for_server()# # 4.发送请求# # 参数1：目标值# # 参数2：最终结果回调# # 参数3：连接被激活的回调# # 参数4：连续反馈# # a.激活处理# # b.连续反馈处理# # c.最终响应结果处理# goal_obj = AddIntsGoal()# goal_obj.num = 10# client.send_goal(goal_obj,done_cb,active_cb,feedback_cb)# # 6.spin()# rospy.spin()#! /usr/bin/env pythonimport rospyimport actionlibfrom demo01_action.msg import *&quot;&quot;&quot; 需求: 创建两个ROS 节点，服务器和客户端， 客户端可以向服务器发送目标数据N(一个整型数据)服务器会计算 1 到 N 之间所有整数的和, 这是一个循环累加的过程，返回给客户端，这是基于请求响应模式的， 又已知服务器从接收到请求到产生响应是一个耗时操作，每累加一次耗时0.1s， 为了良好的用户体验，需要服务器在计算过程中， 每累加一次，就给客户端响应一次百分比格式的执行进度，使用 action实现。 流程: 1.导包 2.初始化 ROS 节点 3.创建 action Client 对象 4.等待服务 5.组织目标对象并发送 6.编写回调, 激活、连续反馈、最终响应 7.spin&quot;&quot;&quot;def done_cb(state,result): if state == actionlib.GoalStatus.SUCCEEDED: rospy.loginfo(&quot;响应结果:%d&quot;,result.result)def active_cb(): rospy.loginfo(&quot;服务被激活....&quot;)def fb_cb(fb): rospy.loginfo(&quot;当前进度:%.2f&quot;,fb.progress_bar)if __name__ == &quot;__main__&quot;: # 2.初始化 ROS 节点 rospy.init_node(&quot;action_client_p&quot;) # 3.创建 action Client 对象 client = actionlib.SimpleActionClient(&quot;addInts&quot;,AddIntsAction) # 4.等待服务 client.wait_for_server() # 5.组织目标对象并发送 goal_obj = AddIntsGoal() goal_obj.num = 10 client.send_goal(goal_obj,done_cb,active_cb,fb_cb) # 6.编写回调, 激活、连续反馈、最终响应 # 7.spin rospy.spin() 动态参数客户端实现123456789101112131415161718192021222324#! /usr/bin/env python&quot;&quot;&quot; 动态参数客户端： 1.导包 2.创建参数生成器 3.往生成器添加参数 4.配置节点，并退出 &quot;&quot;&quot;# from dynamic_reconfigure.parameter_generator_catkin import ParameterGeneratorfrom dynamic_reconfigure.parameter_generator_catkin import *# 2.创建参数生成器gen = ParameterGenerator()# 3.往生成器添加参数gen.add(&quot;int_param&quot;,int_t,0,&quot;整数参数&quot;,10,1,100)gen.add(&quot;double_param&quot;,double_t,0,&quot;浮点参数&quot;,1.57,0,3.14)gen.add(&quot;str_param&quot;,str_t,0,&quot;字符串参数&quot;,&quot;hello param&quot;)gen.add(&quot;bool_param&quot;,bool_t,0,&quot;布尔参数&quot;,True)myList=gen.enum([gen.const(&quot;small&quot;,int_t,0,&quot;small_car&quot;), gen.const(&quot;normal&quot;,int_t,1,&quot;normalcar&quot;), gen.const(&quot;big&quot;,int_t,2,&quot;big_car&quot;), ],&quot;car+size&quot;)gen.add(&quot;list_param&quot;,int_t,0,&quot;列表参数&quot;,0,0,2,edit_method=myList)# 4.配置节点，并退出exit(gen.generate(&quot;demo02_dr&quot;,&quot;dr_client&quot;,&quot;dr&quot;)) 服务端实现c++123456789101112131415161718192021222324252627282930313233343536#include &quot;ros/ros.h&quot;#include &quot;dynamic_reconfigure/server.h&quot;#include &quot;demo02_dr/drConfig.h&quot; /* 动态参数服务端: 参数被修改时直接打印 实现流程: 1.包含头文件 2.初始化 ros 节点 3.创建服务器对象 4.回调函数解析修改后的参数 5.spin()*///解析动态参数void cb(demo02_dr::drConfig &amp;config, uint32_t level)&#123; ROS_INFO(&quot;修改后的整形数据是：%d,%.2f,%s,%d,%d&quot;,config.int_param, config.double_param, config.str_param.c_str(), config.bool_param, config.list_param);&#125;int main(int argc, char *argv[])&#123; // 1.初始化 ros 节点 setlocale(LC_ALL, &quot;&quot;); ros::init(argc, argv,&quot;dr_server&quot;); // 3.创建服务器对象 dynamic_reconfigure::Server&lt;demo02_dr::drConfig&gt; server; // 4.回调函数解析修改后的参数 // void setCallback(const boost::function&lt;void (demo02_dr::drConfig &amp;, uint32_t level)&gt; &amp;callback) server.setCallback(boost::bind(&amp;cb,_1,_2)); // 5.spin() ros::spin(); return 0;&#125; python12345678910111213141516171819202122232425262728293031#! /usr/bin/env pythonimport rospyfrom dynamic_reconfigure.server import Serverfrom demo02_dr.cfg import drConfig&quot;&quot;&quot; 动态参数服务端 1.导包 2.初始化ros节点 3.创建服务端对象 4.回调函数解析参数 5.spin() &quot;&quot;&quot;def cb(drConfig,level): rospy.loginfo(&quot;修改后的整形数据是：%d,%.2f,%s,%d,%d&quot;,drConfig.int_param, drConfig.double_param, drConfig.str_param, drConfig.bool_param, drConfig.list_param) return drConfigif __name__ == &#x27;__main__&#x27;: # 2.初始化ros节点 rospy.init_node(&quot;dr_server_p&quot;) # 3.创建服务端对象 # type类型, callback回调函数, namespace=&quot;&quot; server = Server(drConfig,cb) # 4.回调函数解析参数 # 5.spin() rospy.spin() pluginlib导航插件优点 结构清晰 低耦合，易修改，可维护性强 可移植性强，更具复用性 结构容易调整，插件可以自由增减 具体实现创建基类1234567891011121314151617181920#ifndef DBX_BASE_H_#define DBX_BASE_H_namespace dbx_base_ns&#123; /* 注意：必须保证基类中包含无参构造 */ class Dbx_Base&#123; protected: Dbx_Base()&#123;&#125; public: //计算周长的函数 virtual double getlength() = 0; //初始化边长的函数 virtual void init(double side_length)=0; &#125;;&#125;#endif 创建插件1234567891011121314151617181920212223242526272829303132333435363738#ifndef DBX_PLUGINS_H_#define DBX_PLUGINS_H_#include &quot;demo03_plugin/dbx_base.h&quot;namespace dbx_plugins_ns&#123; //三边 class SanBian:public dbx_base_ns::Dbx_Base&#123; private: double side_length; public: SanBian()&#123; side_length = 0.0; &#125; void init(double side_length)&#123; this-&gt;side_length = side_length; &#125; double getlength()&#123; return side_length*3; &#125; &#125;; //四边 class SiBian:public dbx_base_ns::Dbx_Base&#123; private: double side_length; public: SiBian()&#123; side_length = 0.0; &#125; void init(double side_length)&#123; this-&gt;side_length = side_length; &#125; double getlength()&#123; return side_length*4; &#125; &#125;;&#125;;#endif 注册插件1234567#include &quot;pluginlib/class_list_macros.hpp&quot;#include &quot;demo03_plugin/dbx_base.h&quot;#include &quot;demo03_plugin/dbx_plugins.h&quot;//参数1子类 参数2父类PLUGINLIB_EXPORT_CLASS(dbx_plugins_ns::SanBian,dbx_base_ns::Dbx_Base)PLUGINLIB_EXPORT_CLASS(dbx_plugins_ns::SiBian,dbx_base_ns::Dbx_Base) 编写xml文件1234567891011121314&lt;!-- 需要定位动态连接库 library根标签下的path属性设置 声明子类与父类 library的子标签class声明 --&gt;&lt;library path=&quot;lib/libplus&quot;&gt; &lt;class type=&quot;dbx_plugins_ns::SanBian&quot; base_class_type=&quot;dbx_base_ns::Dbx_Base&quot;&gt; &lt;description&gt; 这是正三边形插件&lt;/description&gt; &lt;/class&gt; &lt;class type=&quot;dbx_plugins_ns::SiBian&quot; base_class_type=&quot;dbx_base_ns::Dbx_Base&quot;&gt; &lt;description&gt; 这是正四边形插件&lt;/description&gt; &lt;/class&gt;&lt;/library&gt; 导出插件1234&lt;export&gt; &lt;!-- Other tools can request additional information be placed here --&gt; &lt;demo03_plugin plugin=&quot;$&#123;prefix&#125;/plus.xml&quot; /&gt;&lt;/export&gt; 调用插件12345678910111213141516171819202122232425262728#include &quot;ros/ros.h&quot;#include &quot;pluginlib/class_loader.h&quot;#include &quot;demo03_plugin/dbx_base.h&quot;/* 创建类加载器，根据需求加载相关插件 1. 创建类加载器 2.使用类加载器实例化某个插件对象 3.使用插件 */int main(int argc, char *argv[])&#123; // 1. 创建类加载器 setlocale(LC_ALL, &quot;&quot;); pluginlib::ClassLoader&lt;dbx_base_ns::Dbx_Base&gt; loader(&quot;demo03_plugin&quot;,&quot;dbx_base_ns::Dbx_Base&quot;); // 2.使用类加载器实例化某个插件对象 boost::shared_ptr&lt;dbx_base_ns::Dbx_Base&gt; san = loader.createInstance(&quot;dbx_plugins_ns::SanBian&quot;); // 3.使用插件 san-&gt;init(10); double length = san-&gt;getlength(); ROS_INFO(&quot;三角形周长：%.2f&quot;,length); boost::shared_ptr&lt;dbx_base_ns::Dbx_Base&gt; si = loader.createInstance(&quot;dbx_plugins_ns::SiBian&quot;); // 3.使用插件 si-&gt;init(10); double length2 = si-&gt;getlength(); ROS_INFO(&quot;四角形周长：%.2f&quot;,length2); return 0;&#125; nodelet基本使用12345678910111213&lt;launch&gt; &lt;!-- 启动nodelet manager(管理器) --&gt; &lt;node pkg=&quot;nodelet&quot; type=&quot;nodelet&quot; args=&quot;manager&quot; name=&quot;dasun&quot; output=&quot;screen&quot; /&gt; &lt;!-- 添加节点小王，参数100 --&gt; &lt;node pkg=&quot;nodelet&quot; type=&quot;nodelet&quot; args=&quot;load nodelet_tutorial_math/Plus dasun&quot; name=&quot;xiaowang&quot; output=&quot;screen&quot; &gt; &lt;param name=&quot;value&quot; value=&quot;100&quot; /&gt; &lt;/node&gt; &lt;!-- 添加节点二狗，参数-50，小王的输出作为二狗的输入 --&gt; &lt;node pkg=&quot;nodelet&quot; type=&quot;nodelet&quot; args=&quot;load nodelet_tutorial_math/Plus dasun&quot; name=&quot;ergou&quot; output=&quot;screen&quot; &gt; &lt;param name=&quot;value&quot; value=&quot;-50&quot; /&gt; &lt;remap from=&quot;/ergou/in&quot; to=&quot;/xiaowang/out&quot; /&gt; &lt;/node&gt;&lt;/launch&gt; 代码实现创建插件类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &quot;ros/ros.h&quot;#include &quot;nodelet/nodelet.h&quot;#include &quot;pluginlib/class_list_macros.h&quot;#include &quot;std_msgs/Float64.h&quot;/* 需求：首先，需要订阅一个浮点数据；然后将订阅的数据与参数服务器的指定参数相加；最后将最终结果发布 流程： 1.先确定需要的变量：订阅对象，发布对象，存储参数的变量 2.获取nodehandle 3.通过nodehandle创建订阅对象和发布对象，解析参数 4.订阅对象回调函数需要处理数据，并通过发布对象发布 */namespace my_nodelet &#123; class MyPlus:public nodelet::Nodelet &#123; private: ros::Publisher pub; ros::Subscriber sub; double value; public: MyPlus()&#123; value = 0.0; &#125; void onInit()&#123; ROS_INFO(&quot;hello nodelet--------------------------------&quot;); // 2.获取nodehandle 获取私有的 ros::NodeHandle nh = getPrivateNodeHandle(); // 3.通过nodehandle创建订阅对象和发布对象，解析参数 nh.getParam(&quot;value&quot;,value); pub = nh.advertise&lt;std_msgs::Float64&gt;(&quot;out&quot;,100);//话题名称 ：/节点名/in sub = nh.subscribe&lt;std_msgs::Float64&gt;(&quot;in&quot;,100,&amp;MyPlus::cb,this); // 4.订阅对象回调函数需要处理数据，并通过发布对象发布 &#125; // 处理订阅的回调函数 void cb(const std_msgs::Float64::ConstPtr&amp; p)&#123; //4-1解析订阅的数据 double in = p-&gt;data; // 4-2和参数相加 double out = in+value; // 4-3发布 std_msgs::Float64 out_msg; out_msg.data = out; pub.publish(out_msg); &#125; &#125;;&#125;;PLUGINLIB_EXPORT_CLASS(my_nodelet::MyPlus,nodelet::Nodelet) 配置xml文件12345&lt;library path=&quot;lib/libmyplus&quot; &gt; &lt;class type=&quot;my_nodelet::MyPlus&quot; base_class_type=&quot;nodelet::Nodelet&quot; name=&quot;demo04_nodelet/MyPlus&quot;&gt; &lt;description&gt;自定义插件&lt;/description&gt; &lt;/class&gt;&lt;/library&gt; 导出插件12345&lt;export&gt; &lt;!-- Other tools can request additional information be placed here --&gt; &lt;!-- 标签名基类的包名 --&gt; &lt;nodelet plugin=&quot;$&#123;prefix&#125;/myplus.xml&quot; /&gt; &lt;/export&gt;","categories":[],"tags":[]},{"title":"更新日志","slug":"更新日志","date":"2022-07-26T15:43:08.000Z","updated":"2022-07-29T14:34:55.883Z","comments":true,"path":"2022/07/26/更新日志/","link":"","permalink":"http://example.com/2022/07/26/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/","excerpt":"","text":"日志关于hello,欢迎来到迷途的小窝，本站将不定期更新个人生活及学习博客 建站进度目前仅搭建博客版块，后续更新其他板块","categories":[],"tags":[{"name":"迷途","slug":"迷途","permalink":"http://example.com/tags/%E8%BF%B7%E9%80%94/"}]},{"title":"测试","slug":"测试","date":"2022-07-26T15:43:08.000Z","updated":"2022-07-29T14:26:03.849Z","comments":true,"path":"2022/07/26/测试/","link":"","permalink":"http://example.com/2022/07/26/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"测试","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"迷途","slug":"迷途","permalink":"http://example.com/tags/%E8%BF%B7%E9%80%94/"}]}